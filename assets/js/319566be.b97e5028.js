"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[2634],{5017(e,n,r){r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>u,frontMatter:()=>c,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"signatures/x25519","title":"X25519","description":"Elliptic curve Diffie Hellman key exchange on Curve25519. Use this to create shared secrets between two parties who only know each other\'s public keys.","source":"@site/docs/signatures/x25519.md","sourceDirName":"signatures","slug":"/signatures/x25519","permalink":"/docs/signatures/x25519","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/signatures/x25519.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Ed25519 (EdDSA)","permalink":"/docs/signatures/eddsa"},"next":{"title":"ML DSA (Post Quantum Signatures)","permalink":"/docs/signatures/mldsa"}}');var s=r(4848),i=r(8453);const c={sidebar_position:2},l="X25519",t={},o=[{value:"Masked Key Operations",id:"masked-key-operations",level:2},{value:"<code>X25519.Mask(SecretKey: buffer) -&gt; buffer</code>",id:"x25519masksecretkey-buffer---buffer",level:3},{value:"<code>X25519.MaskSignature(SignatureSecretKey: buffer) -&gt; buffer</code>",id:"x25519masksignaturesignaturesecretkey-buffer---buffer",level:3},{value:"<code>X25519.Remask(MaskedKey: buffer) -&gt; buffer</code>",id:"x25519remaskmaskedkey-buffer---buffer",level:3},{value:"<code>X25519.PublicKey(MaskedKey: buffer) -&gt; buffer</code>",id:"x25519publickeymaskedkey-buffer---buffer",level:3},{value:"<code>X25519.MaskComponent(MaskedKey: buffer) -&gt; buffer</code>",id:"x25519maskcomponentmaskedkey-buffer---buffer",level:3},{value:"Key Exchange",id:"key-exchange",level:2},{value:"<code>X25519.Exchange(MaskedSecretKey: buffer, TheirPublicKey: buffer) -&gt; (buffer, buffer)</code>",id:"x25519exchangemaskedsecretkey-buffer-theirpublickey-buffer---buffer-buffer",level:3},{value:"Deriving Keys",id:"deriving-keys",level:2},{value:"Forward Secrecy",id:"forward-secrecy",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Security Properties",id:"security-properties",level:2},{value:"Authenticated Key Exchange",id:"authenticated-key-exchange",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"x25519",children:"X25519"})}),"\n",(0,s.jsx)(n.p,{children:"Elliptic curve Diffie Hellman key exchange on Curve25519. Use this to create shared secrets between two parties who only know each other's public keys."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"local X25519 = Cryptography.Verification.EdDSA.X25519\n"})}),"\n",(0,s.jsx)(n.h2,{id:"masked-key-operations",children:"Masked Key Operations"}),"\n",(0,s.jsx)(n.p,{children:"X25519 in this library uses masked keys for additional security. The masking adds a layer of protection against certain side channel attacks."}),"\n",(0,s.jsx)(n.h3,{id:"x25519masksecretkey-buffer---buffer",children:(0,s.jsx)(n.code,{children:"X25519.Mask(SecretKey: buffer) -> buffer"})}),"\n",(0,s.jsx)(n.p,{children:"Creates a masked key from a secret key."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"local SecretKey = CSPRNG.Ed25519Random()\nlocal MaskedKey = X25519.Mask(SecretKey)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"x25519masksignaturesignaturesecretkey-buffer---buffer",children:(0,s.jsx)(n.code,{children:"X25519.MaskSignature(SignatureSecretKey: buffer) -> buffer"})}),"\n",(0,s.jsx)(n.p,{children:"Creates a masked key from an Ed25519 signature secret key, allowing you to use the same key material for both signing and key exchange."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"local EdSecretKey = CSPRNG.Ed25519Random()\nlocal MaskedKey = X25519.MaskSignature(EdSecretKey)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"x25519remaskmaskedkey-buffer---buffer",children:(0,s.jsx)(n.code,{children:"X25519.Remask(MaskedKey: buffer) -> buffer"})}),"\n",(0,s.jsx)(n.p,{children:"Refreshes the mask on an already masked key."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"local RemaskedKey = X25519.Remask(MaskedKey)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"x25519publickeymaskedkey-buffer---buffer",children:(0,s.jsx)(n.code,{children:"X25519.PublicKey(MaskedKey: buffer) -> buffer"})}),"\n",(0,s.jsx)(n.p,{children:"Derives a 32 byte public key from a masked key."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"local PublicKey = X25519.PublicKey(MaskedKey)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"x25519maskcomponentmaskedkey-buffer---buffer",children:(0,s.jsx)(n.code,{children:"X25519.MaskComponent(MaskedKey: buffer) -> buffer"})}),"\n",(0,s.jsx)(n.p,{children:"Extracts the mask component from a masked key."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"local MaskComponent = X25519.MaskComponent(MaskedKey)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"key-exchange",children:"Key Exchange"}),"\n",(0,s.jsx)(n.h3,{id:"x25519exchangemaskedsecretkey-buffer-theirpublickey-buffer---buffer-buffer",children:(0,s.jsx)(n.code,{children:"X25519.Exchange(MaskedSecretKey: buffer, TheirPublicKey: buffer) -> (buffer, buffer)"})}),"\n",(0,s.jsx)(n.p,{children:"Performs the key exchange. Returns two buffers."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"-- Alice generates her keypair\nlocal AliceSecret = CSPRNG.Ed25519Random()\nlocal AliceMasked = X25519.Mask(AliceSecret)\nlocal AlicePublic = X25519.PublicKey(AliceMasked)\n\n-- Bob generates his keypair\nlocal BobSecret = CSPRNG.Ed25519Random()\nlocal BobMasked = X25519.Mask(BobSecret)\nlocal BobPublic = X25519.PublicKey(BobMasked)\n\n-- They exchange public keys (over an insecure channel)\n\n-- Alice computes shared secret\nlocal AliceShared1, AliceShared2 = X25519.Exchange(AliceMasked, BobPublic)\n\n-- Bob computes shared secret\nlocal BobShared1, BobShared2 = X25519.Exchange(BobMasked, AlicePublic)\n"})}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart LR\n    subgraph Alice\n        A1[Generate Secret] --\x3e A2[Mask Key] --\x3e A3[Get Public]\n    end\n    \n    subgraph Bob\n        B1[Generate Secret] --\x3e B2[Mask Key] --\x3e B3[Get Public]\n    end\n    \n    A3 --\x3e|AlicePublic| B4[Exchange]\n    B3 --\x3e|BobPublic| A4[Exchange]\n    \n    A4 --\x3e S[Same Shared Secret]\n    B4 --\x3e S\n    \n    style A1 fill:#3c3c5a\n    style A2 fill:#3c3c5a\n    style A3 fill:#3c3c5a\n    style B1 fill:#3c5a3c\n    style B2 fill:#3c5a3c\n    style B3 fill:#3c5a3c\n    style A4 fill:#503c50\n    style B4 fill:#503c50\n    style S fill:#5a4632"}),"\n",(0,s.jsx)(n.h2,{id:"deriving-keys",children:"Deriving Keys"}),"\n",(0,s.jsx)(n.p,{children:"The raw shared secret should not be used directly as an encryption key. Run it through a key derivation function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:'local Shared1, Shared2 = X25519.Exchange(MyMasked, TheirPublic)\n\n-- Derive encryption key using BLAKE3\nlocal Context = buffer.fromstring("MyApp encryption key")\nlocal KeyDeriver = Blake3.DeriveKey(Context)\nlocal _, EncryptionKey = KeyDeriver(Shared1, 32)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"forward-secrecy",children:"Forward Secrecy"}),"\n",(0,s.jsx)(n.p,{children:"For forward secrecy, generate ephemeral keypairs for each session:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:'-- Session setup\nlocal EphemeralSecret = CSPRNG.Ed25519Random()\nlocal EphemeralMasked = X25519.Mask(EphemeralSecret)\nlocal EphemeralPublic = X25519.PublicKey(EphemeralMasked)\n\n-- Exchange ephemeral public keys with peer\n\n-- Compute session key\nlocal SessionShared1, _ = X25519.Exchange(EphemeralMasked, PeerEphemeralPublic)\nlocal Context = buffer.fromstring("session key")\nlocal SessionDeriver = Blake3.DeriveKey(Context)\nlocal _, SessionKey = SessionDeriver(SessionShared1, 32)\n'})}),"\n",(0,s.jsx)(n.p,{children:"If long term keys are later compromised, past session keys remain secure because the ephemeral secret keys are gone."}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph Setup\n        Gen[Generate Secret] --\x3e Mask --\x3e Public[Get Public Key]\n    end\n    \n    Public --\x3e|EphemeralPublic| Exchange\n    Peer[PeerEphemeralPublic] --\x3e Exchange\n    \n    subgraph Derive["Key Derivation"]\n        Exchange --\x3e Shared[SessionShared1]\n        Shared --\x3e Blake3[Blake3.DeriveKey]\n        Context[Context: session key] --\x3e Blake3\n        Blake3 --\x3e Key[SessionKey 32 bytes]\n    end\n    \n    style Gen fill:#3c3c5a\n    style Mask fill:#3c3c5a\n    style Public fill:#3c3c5a\n    style Peer fill:#3c5a3c\n    style Exchange fill:#503c50\n    style Shared fill:#503c50\n    style Blake3 fill:#5a4632\n    style Context fill:#5a4632\n    style Key fill:#5a5a32'}),"\n",(0,s.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsx)(n.p,{children:"X25519 uses the Montgomery curve Curve25519 (different representation than Ed25519's Edwards curve, but mathematically equivalent). The implementation uses Montgomery ladder for scalar multiplication and projective coordinates to avoid expensive field inversions."}),"\n",(0,s.jsx)(n.p,{children:"The masking provides additional protection by splitting the secret key into shares, making it harder to extract through side channels."}),"\n",(0,s.jsx)(n.h2,{id:"security-properties",children:"Security Properties"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Security level"})," Around 128 bits"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Small subgroup attacks"})," The clamping prevents these by ensuring scalars are multiples of the cofactor (8)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Not authenticated"})," X25519 alone does not prove you are talking to who you think. An active attacker can perform a man in the middle attack. Combine with signatures or a pre shared key for authentication."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Not quantum resistant"})," A quantum computer could break X25519. Use ML KEM if you need post quantum security."]}),"\n",(0,s.jsx)(n.h2,{id:"authenticated-key-exchange",children:"Authenticated Key Exchange"}),"\n",(0,s.jsx)(n.p,{children:"Combine X25519 with Ed25519 signatures:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:'-- Both parties have Ed25519 identity keys for signing\n-- Both parties have X25519 keys for exchange\n\n-- Alice signs her X25519 public key\nlocal AliceSig = EdDSA.Sign(AliceX25519Public, AliceEdSecret, AliceEdPublic)\n\n-- Bob verifies Alice\'s X25519 key came from Alice\nlocal Valid = EdDSA.Verify(AliceX25519Public, AliceEdPublic, AliceSig)\nif not Valid then error("Invalid signature") end\n\n-- Now Bob can trust the X25519 exchange\nlocal Shared1, Shared2 = X25519.Exchange(BobMasked, AliceX25519Public)\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>c,x:()=>l});var a=r(6540);const s={},i=a.createContext(s);function c(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);