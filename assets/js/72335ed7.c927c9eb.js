"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[7163],{6894(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>f,frontMatter:()=>i,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"hashing/blake","title":"BLAKE","description":"Modern hash functions that are faster than SHA2 while having better security. If you are starting fresh and do not need SHA2 compatibility, BLAKE3 is probably what you want.","source":"@site/docs/hashing/blake.md","sourceDirName":"hashing","slug":"/hashing/blake","permalink":"/docs/hashing/blake","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/hashing/blake.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"SHA3","permalink":"/docs/hashing/sha3"},"next":{"title":"HMAC","permalink":"/docs/hashing/hmac"}}');var a=t(4848),s=t(8453);const i={sidebar_position:3},l="BLAKE",o={},u=[{value:"BLAKE2b",id:"blake2b",level:2},{value:"<code>Blake2b(InputData: buffer, OutputLength: number?, KeyData: buffer?) -&gt; (string, buffer)</code>",id:"blake2binputdata-buffer-outputlength-number-keydata-buffer---string-buffer",level:3},{value:"BLAKE3",id:"blake3",level:2},{value:"<code>Blake3.Digest(Message: buffer, Length: number?) -&gt; (string, buffer)</code>",id:"blake3digestmessage-buffer-length-number---string-buffer",level:3},{value:"<code>Blake3.DigestKeyed(Message: buffer, Key: buffer, Length: number?) -&gt; (string, buffer)</code>",id:"blake3digestkeyedmessage-buffer-key-buffer-length-number---string-buffer",level:3},{value:"<code>Blake3.DeriveKey(Context: buffer) -&gt; (Message: buffer, Length: number?) -&gt; (string, buffer)</code>",id:"blake3derivekeycontext-buffer---message-buffer-length-number---string-buffer",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",mermaid:"mermaid",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"blake",children:"BLAKE"})}),"\n",(0,a.jsx)(n.p,{children:"Modern hash functions that are faster than SHA2 while having better security. If you are starting fresh and do not need SHA2 compatibility, BLAKE3 is probably what you want."}),"\n",(0,a.jsx)(n.h2,{id:"blake2b",children:"BLAKE2b"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:"local Blake2b = Cryptography.Hashing.Blake2b\n"})}),"\n",(0,a.jsx)(n.h3,{id:"blake2binputdata-buffer-outputlength-number-keydata-buffer---string-buffer",children:(0,a.jsx)(n.code,{children:"Blake2b(InputData: buffer, OutputLength: number?, KeyData: buffer?) -> (string, buffer)"})}),"\n",(0,a.jsx)(n.p,{children:"BLAKE2b with optional output length and optional key for keyed hashing."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:'-- Simple hash (default 64 byte output)\nlocal HexDigest, RawDigest = Blake2b(buffer.fromstring("Hello"))\nprint(buffer.len(RawDigest)) -- 64\n\n-- Custom output length\nlocal ShortHex, ShortRaw = Blake2b(buffer.fromstring("data"), 32)\nprint(buffer.len(ShortRaw)) -- 32\n\n-- Keyed hash (works as a MAC)\nlocal Key = buffer.fromstring("my-secret-key-32-bytes-long!!!!!")\nlocal KeyedHex, KeyedRaw = Blake2b(buffer.fromstring("message"), 64, Key)\n'})}),"\n",(0,a.jsx)(n.p,{children:"BLAKE2b is faster than MD5 while being as secure as SHA3. The keyed mode is built into the algorithm, making it simpler and faster than HMAC for MAC use cases. It uses a modified ChaCha permutation internally."}),"\n",(0,a.jsx)(n.h2,{id:"blake3",children:"BLAKE3"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:"local Blake3 = Cryptography.Hashing.Blake3\n"})}),"\n",(0,a.jsx)(n.p,{children:"BLAKE3 is the latest iteration. Parallelizable, faster than BLAKE2, and extremely versatile with three modes."}),"\n",(0,a.jsx)(n.h3,{id:"blake3digestmessage-buffer-length-number---string-buffer",children:(0,a.jsx)(n.code,{children:"Blake3.Digest(Message: buffer, Length: number?) -> (string, buffer)"})}),"\n",(0,a.jsx)(n.p,{children:"Standard hashing. Returns hex string and raw buffer."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:'local HexDigest, RawDigest = Blake3.Digest(buffer.fromstring("Hello World"), 32)\nprint(HexDigest) -- hex string\nprint(buffer.len(RawDigest)) -- 32\n'})}),"\n",(0,a.jsx)(n.h3,{id:"blake3digestkeyedmessage-buffer-key-buffer-length-number---string-buffer",children:(0,a.jsx)(n.code,{children:"Blake3.DigestKeyed(Message: buffer, Key: buffer, Length: number?) -> (string, buffer)"})}),"\n",(0,a.jsx)(n.p,{children:"Keyed hash mode for MACs. Key must be exactly 32 bytes."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:'local Key = CSPRNG.RandomBytes(32)\nlocal HexMac, RawMac = Blake3.DigestKeyed(buffer.fromstring("message"), Key, 32)\n'})}),"\n",(0,a.jsx)(n.p,{children:"This is faster than HMAC and just as secure. The key is mixed into the initialization vector rather than processed through the compression function twice like HMAC."}),"\n",(0,a.jsx)(n.h3,{id:"blake3derivekeycontext-buffer---message-buffer-length-number---string-buffer",children:(0,a.jsx)(n.code,{children:"Blake3.DeriveKey(Context: buffer) -> (Message: buffer, Length: number?) -> (string, buffer)"})}),"\n",(0,a.jsx)(n.p,{children:"Key derivation mode. Returns a function that derives keys from input material."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:'local Context = buffer.fromstring("MyApp 2024 session key")\nlocal KeyDeriver = Blake3.DeriveKey(Context)\n\nlocal MasterSecret = buffer.fromstring("shared secret from key exchange")\n\n-- Derive an encryption key\nlocal EncKeyHex, EncKeyRaw = KeyDeriver(MasterSecret, 32)\n\n-- Derive a different key with different context\nlocal MacContext = buffer.fromstring("MyApp 2024 mac key")\nlocal MacDeriver = Blake3.DeriveKey(MacContext)\nlocal MacKeyHex, MacKeyRaw = MacDeriver(MasterSecret, 32)\n'})}),"\n",(0,a.jsx)(n.mermaid,{value:"flowchart LR\n    MS[Master Secret] --\x3e D1[DeriveKey]\n    MS --\x3e D2[DeriveKey]\n    MS --\x3e D3[DeriveKey]\n    \n    C1[Context: encryption] --\x3e D1\n    C2[Context: mac] --\x3e D2\n    C3[Context: auth] --\x3e D3\n    \n    D1 --\x3e EK[Encryption Key]\n    D2 --\x3e MK[MAC Key]\n    D3 --\x3e AK[Auth Key]\n    \n    style MS fill:#3c5a3c\n    style C1 fill:#3c3c5a\n    style C2 fill:#3c3c5a\n    style C3 fill:#3c3c5a\n    style D1 fill:#503c50\n    style D2 fill:#503c50\n    style D3 fill:#503c50\n    style EK fill:#5a4632\n    style MK fill:#5a4632\n    style AK fill:#5a4632"}),"\n",(0,a.jsx)(n.p,{children:"The context string ensures that keys derived for different purposes are cryptographically independent, even from the same master secret. This is cleaner than concatenating purpose strings to your key material."}),"\n",(0,a.jsx)(n.p,{children:"BLAKE3 uses a Merkle tree structure internally with 1024 byte chunks. The compression function is similar to BLAKE2s but uses permuted message words between rounds instead of a fixed schedule. The tree structure means it can be parallelized, though in single threaded Luau you will not see that benefit."})]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>i,x:()=>l});var r=t(6540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);