"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[942],{1652(e,t,a){a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"hashing/kmac","title":"KMAC","description":"Keccak Message Authentication Code. SHA3\'s native MAC mode with built in domain separation.","source":"@site/docs/hashing/kmac.md","sourceDirName":"hashing","slug":"/hashing/kmac","permalink":"/docs/hashing/kmac","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/hashing/kmac.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"HMAC","permalink":"/docs/hashing/hmac"},"next":{"title":"Non Cryptographic Hashes","permalink":"/docs/hashing/legacy"}}');var r=a(4848),s=a(8453);const o={sidebar_position:5},i="KMAC",u={},c=[{value:"Functions",id:"functions",level:2},{value:"<code>KMAC.KMAC128(Data: buffer, Key: buffer, Output: buffer, CustomBuffer: buffer?) -&gt; (string, buffer)</code>",id:"kmackmac128data-buffer-key-buffer-output-buffer-custombuffer-buffer---string-buffer",level:3},{value:"<code>KMAC.KMAC256(Data: buffer, Key: buffer, Output: buffer, CustomBuffer: buffer?) -&gt; (string, buffer)</code>",id:"kmackmac256data-buffer-key-buffer-output-buffer-custombuffer-buffer---string-buffer",level:3},{value:"Domain Separation",id:"domain-separation",level:2},{value:"KMAC vs HMAC",id:"kmac-vs-hmac",level:2}];function f(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"kmac",children:"KMAC"})}),"\n",(0,r.jsx)(t.p,{children:"Keccak Message Authentication Code. SHA3's native MAC mode with built in domain separation."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-luau",children:"local KMAC = Cryptography.Hashing.KMAC\n"})}),"\n",(0,r.jsx)(t.h2,{id:"functions",children:"Functions"}),"\n",(0,r.jsx)(t.h3,{id:"kmackmac128data-buffer-key-buffer-output-buffer-custombuffer-buffer---string-buffer",children:(0,r.jsx)(t.code,{children:"KMAC.KMAC128(Data: buffer, Key: buffer, Output: buffer, CustomBuffer: buffer?) -> (string, buffer)"})}),"\n",(0,r.jsx)(t.p,{children:"KMAC with 128 bit security level."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-luau",children:'local Key = CSPRNG.RandomBytes(32)\nlocal Data = buffer.fromstring("message to authenticate")\nlocal Output = buffer.create(32) -- you provide the output buffer\n\nlocal HexMac, RawMac = KMAC.KMAC128(Data, Key, Output)\nprint(HexMac)\n'})}),"\n",(0,r.jsx)(t.h3,{id:"kmackmac256data-buffer-key-buffer-output-buffer-custombuffer-buffer---string-buffer",children:(0,r.jsx)(t.code,{children:"KMAC.KMAC256(Data: buffer, Key: buffer, Output: buffer, CustomBuffer: buffer?) -> (string, buffer)"})}),"\n",(0,r.jsx)(t.p,{children:"KMAC with 256 bit security level."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-luau",children:'local Key = CSPRNG.RandomBytes(32)\nlocal Data = buffer.fromstring("message")\nlocal Output = buffer.create(64)\n\nlocal HexMac, RawMac = KMAC.KMAC256(Data, Key, Output)\n'})}),"\n",(0,r.jsx)(t.h2,{id:"domain-separation",children:"Domain Separation"}),"\n",(0,r.jsxs)(t.p,{children:["The optional ",(0,r.jsx)(t.code,{children:"CustomBuffer"})," parameter lets you separate different uses of the same key:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-luau",children:'local Key = CSPRNG.RandomBytes(32)\nlocal Data = buffer.fromstring("shared data")\n\n-- MAC for API requests\nlocal ApiOutput = buffer.create(32)\nlocal ApiMac, _ = KMAC.KMAC256(Data, Key, ApiOutput, buffer.fromstring("api-auth"))\n\n-- MAC for storage integrity\nlocal StorageOutput = buffer.create(32)\nlocal StorageMac, _ = KMAC.KMAC256(Data, Key, StorageOutput, buffer.fromstring("storage-check"))\n\n-- These MACs are different even though Key and Data are the same\n'})}),"\n",(0,r.jsx)(t.p,{children:"This is built into the algorithm, so you do not need to manually concatenate strings or worry about length extension attacks."}),"\n",(0,r.jsx)(t.h2,{id:"kmac-vs-hmac",children:"KMAC vs HMAC"}),"\n",(0,r.jsx)(t.p,{children:"KMAC has a few advantages over HMAC: variable output length, built in customization/domain separation, and no length extension vulnerability (not that HMAC has one either, but SHA3's sponge construction makes it structurally impossible)."}),"\n",(0,r.jsx)(t.p,{children:"Use KMAC when you are already using SHA3/SHAKE in your system, or when you need the domain separation feature. Use HMAC when you need compatibility with existing systems or standards that specify HMAC."})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}},8453(e,t,a){a.d(t,{R:()=>o,x:()=>i});var n=a(6540);const r={},s=n.createContext(r);function o(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);