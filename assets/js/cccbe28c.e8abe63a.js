"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[595],{5014(e,r,t){t.d(r,{A:()=>d,W:()=>c});var s=t(6540),n=t(5622),i=t(5293),a=(t(1388),t(4848));function c(e,r,t){return{id:e,source:r,target:t,type:"smoothstep",animated:!0}}function l({nodes:e,edges:r}){const{colorMode:t}=(0,i.G)(),c="dark"===t,l=(0,n.VH)(),d=(0,s.useRef)(null);(0,s.useEffect)(()=>{if(!d.current)return;const e=new ResizeObserver(()=>{l.fitView({padding:.2})});return e.observe(d.current),()=>e.disconnect()},[l]);return(0,a.jsx)("div",{ref:d,style:{width:"100%",height:"100%"},children:(0,a.jsx)(n.Gc,{nodes:e(e=>({background:e,color:"#fff",border:"none",borderRadius:8,fontSize:14,padding:"10px 20px"}),c),edges:r,fitView:!0,fitViewOptions:{padding:.2},preventScrolling:!1,nodesDraggable:!1,nodesConnectable:!1,elementsSelectable:!1,proOptions:{hideAttribution:!0}})})}function d({nodes:e,edges:r,className:t}){return(0,a.jsx)("div",{className:t,children:(0,a.jsx)(n.Ln,{children:(0,a.jsx)(l,{nodes:e,edges:r})})})}},8386(e,r,t){t.r(r),t.d(r,{assets:()=>f,contentTitle:()=>u,default:()=>b,frontMatter:()=>d,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"signatures/mlkem","title":"ML KEM (Post Quantum Key Exchange)","description":"Module Lattice Key Encapsulation Mechanism. This is the NIST post quantum key exchange standard, formerly known as Kyber. Use this to establish shared secrets that will remain secure against quantum computers.","source":"@site/docs/signatures/mlkem.md","sourceDirName":"signatures","slug":"/signatures/mlkem","permalink":"/docs/signatures/mlkem","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/signatures/mlkem.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"ML DSA (Post Quantum Signatures)","permalink":"/docs/signatures/mldsa"},"next":{"title":"Utilities","permalink":"/docs/category/utilities"}}');var n=t(4848),i=t(8453),a=t(5622),c=t(5014);function l(){return(0,n.jsx)(c.A,{className:"mlkem-flow-wrapper",nodes:(e,r)=>[{id:"gen",position:{x:0,y:70},data:{label:"GenerateKeys"},style:e(r?"#22c55e":"#4ade80"),sourcePosition:a.yX.Right},{id:"pk",position:{x:200,y:0},data:{label:"PublicKey"},style:e(r?"#22c55e":"#4ade80"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"sk",position:{x:200,y:140},data:{label:"SecretKey"},style:e(r?"#22c55e":"#4ade80"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"enc",position:{x:400,y:0},data:{label:"Encapsulate"},style:e(r?"#6366f1":"#818cf8"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"ss1",position:{x:600,y:0},data:{label:"SharedSecret"},style:e(r?"#6366f1":"#818cf8"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"ct",position:{x:600,y:70},data:{label:"Ciphertext"},style:e(r?"#f59e0b":"#fbbf24"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"encrypt",position:{x:800,y:0},data:{label:"Encrypt"},style:e(r?"#8b5cf6":"#a78bfa"),targetPosition:a.yX.Left},{id:"dec",position:{x:400,y:140},data:{label:"Decapsulate"},style:e(r?"#22c55e":"#4ade80"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"ss2",position:{x:600,y:140},data:{label:"SharedSecret"},style:e(r?"#22c55e":"#4ade80"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"decrypt",position:{x:800,y:140},data:{label:"Decrypt"},style:e(r?"#16a34a":"#22c55e"),targetPosition:a.yX.Left}],edges:[(0,c.W)("gen-pk","gen","pk"),(0,c.W)("gen-sk","gen","sk"),(0,c.W)("pk-enc","pk","enc"),(0,c.W)("enc-ss1","enc","ss1"),(0,c.W)("enc-ct","enc","ct"),(0,c.W)("ss1-encrypt","ss1","encrypt"),(0,c.W)("ct-dec","ct","dec"),(0,c.W)("sk-dec","sk","dec"),(0,c.W)("dec-ss2","dec","ss2"),(0,c.W)("ss2-decrypt","ss2","decrypt")]})}const d={sidebar_position:4},u="ML KEM (Post Quantum Key Exchange)",f={},o=[{value:"Security Levels",id:"security-levels",level:2},{value:"Key Generation",id:"key-generation",level:2},{value:"<code>MLKEM_512.GenerateKeys() -&gt; (buffer, buffer)</code>",id:"mlkem_512generatekeys---buffer-buffer",level:3},{value:"<code>MLKEM_768.GenerateKeys() -&gt; (buffer, buffer)</code>",id:"mlkem_768generatekeys---buffer-buffer",level:3},{value:"<code>MLKEM_1024.GenerateKeys() -&gt; (buffer, buffer)</code>",id:"mlkem_1024generatekeys---buffer-buffer",level:3},{value:"<code>MLKEM_512.KeyGen(D: buffer, Z: buffer) -&gt; (buffer, buffer)</code>",id:"mlkem_512keygend-buffer-z-buffer---buffer-buffer",level:3},{value:"<code>MLKEM_768.KeyGen(D: buffer, Z: buffer) -&gt; (buffer, buffer)</code>",id:"mlkem_768keygend-buffer-z-buffer---buffer-buffer",level:3},{value:"<code>MLKEM_1024.KeyGen(D: buffer, Z: buffer) -&gt; (buffer, buffer)</code>",id:"mlkem_1024keygend-buffer-z-buffer---buffer-buffer",level:3},{value:"Encapsulation",id:"encapsulation",level:2},{value:"<code>MLKEM_512.Encapsulate(Message: buffer, PublicKey: buffer) -&gt; (buffer?, buffer?)</code>",id:"mlkem_512encapsulatemessage-buffer-publickey-buffer---buffer-buffer",level:3},{value:"<code>MLKEM_768.Encapsulate(Message: buffer, PublicKey: buffer) -&gt; (buffer?, buffer?)</code>",id:"mlkem_768encapsulatemessage-buffer-publickey-buffer---buffer-buffer",level:3},{value:"<code>MLKEM_1024.Encapsulate(Message: buffer, PublicKey: buffer) -&gt; (buffer?, buffer?)</code>",id:"mlkem_1024encapsulatemessage-buffer-publickey-buffer---buffer-buffer",level:3},{value:"Decapsulation",id:"decapsulation",level:2},{value:"<code>MLKEM_512.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -&gt; buffer</code>",id:"mlkem_512decapsulateciphertext-buffer-secretkey-buffer---buffer",level:3},{value:"<code>MLKEM_768.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -&gt; buffer</code>",id:"mlkem_768decapsulateciphertext-buffer-secretkey-buffer---buffer",level:3},{value:"<code>MLKEM_1024.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -&gt; buffer</code>",id:"mlkem_1024decapsulateciphertext-buffer-secretkey-buffer---buffer",level:3},{value:"KEM vs DH",id:"kem-vs-dh",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Examples",id:"examples",level:2},{value:"When to Use ML KEM",id:"when-to-use-ml-kem",level:2},{value:"Performance Notes",id:"performance-notes",level:2}];function h(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"ml-kem-post-quantum-key-exchange",children:"ML KEM (Post Quantum Key Exchange)"})}),"\n","\n",(0,n.jsx)(r.p,{children:"Module Lattice Key Encapsulation Mechanism. This is the NIST post quantum key exchange standard, formerly known as Kyber. Use this to establish shared secrets that will remain secure against quantum computers."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-luau",children:"local MlKem = Cryptography.Verification.MlKem\n"})}),"\n",(0,n.jsx)(r.h2,{id:"security-levels",children:"Security Levels"}),"\n",(0,n.jsxs)(r.table,{children:[(0,n.jsx)(r.thead,{children:(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.th,{children:"Variant"}),(0,n.jsx)(r.th,{children:"Security"}),(0,n.jsx)(r.th,{children:"Public Key"}),(0,n.jsx)(r.th,{children:"Secret Key"}),(0,n.jsx)(r.th,{children:"Ciphertext"}),(0,n.jsx)(r.th,{children:"Shared Secret"})]})}),(0,n.jsxs)(r.tbody,{children:[(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"MLKEM_512"}),(0,n.jsx)(r.td,{children:"AES 128 equivalent"}),(0,n.jsx)(r.td,{children:"800 bytes"}),(0,n.jsx)(r.td,{children:"1,632 bytes"}),(0,n.jsx)(r.td,{children:"768 bytes"}),(0,n.jsx)(r.td,{children:"32 bytes"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"MLKEM_768"}),(0,n.jsx)(r.td,{children:"AES 192 equivalent"}),(0,n.jsx)(r.td,{children:"1,184 bytes"}),(0,n.jsx)(r.td,{children:"2,400 bytes"}),(0,n.jsx)(r.td,{children:"1,088 bytes"}),(0,n.jsx)(r.td,{children:"32 bytes"})]}),(0,n.jsxs)(r.tr,{children:[(0,n.jsx)(r.td,{children:"MLKEM_1024"}),(0,n.jsx)(r.td,{children:"AES 256 equivalent"}),(0,n.jsx)(r.td,{children:"1,568 bytes"}),(0,n.jsx)(r.td,{children:"3,168 bytes"}),(0,n.jsx)(r.td,{children:"1,568 bytes"}),(0,n.jsx)(r.td,{children:"32 bytes"})]})]})]}),"\n",(0,n.jsx)(r.p,{children:"Compare to X25519's 32 byte keys and no ciphertext (just public key exchange)."}),"\n",(0,n.jsx)(r.h2,{id:"key-generation",children:"Key Generation"}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_512generatekeys---buffer-buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_512.GenerateKeys() -> (buffer, buffer)"})}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_768generatekeys---buffer-buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_768.GenerateKeys() -> (buffer, buffer)"})}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_1024generatekeys---buffer-buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_1024.GenerateKeys() -> (buffer, buffer)"})}),"\n",(0,n.jsx)(r.p,{children:"Generates an encapsulation keypair. Returns (PublicKey, SecretKey)."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-luau",children:"local PublicKey, SecretKey = MlKem.MLKEM_768.GenerateKeys()\n"})}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_512keygend-buffer-z-buffer---buffer-buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_512.KeyGen(D: buffer, Z: buffer) -> (buffer, buffer)"})}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_768keygend-buffer-z-buffer---buffer-buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_768.KeyGen(D: buffer, Z: buffer) -> (buffer, buffer)"})}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_1024keygend-buffer-z-buffer---buffer-buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_1024.KeyGen(D: buffer, Z: buffer) -> (buffer, buffer)"})}),"\n",(0,n.jsx)(r.p,{children:"Deterministic key generation from seed values."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-luau",children:"local D = CSPRNG.RandomBytes(32)\nlocal Z = CSPRNG.RandomBytes(32)\nlocal PublicKey, SecretKey = MlKem.MLKEM_768.KeyGen(D, Z)\n"})}),"\n",(0,n.jsx)(r.h2,{id:"encapsulation",children:"Encapsulation"}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_512encapsulatemessage-buffer-publickey-buffer---buffer-buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_512.Encapsulate(Message: buffer, PublicKey: buffer) -> (buffer?, buffer?)"})}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_768encapsulatemessage-buffer-publickey-buffer---buffer-buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_768.Encapsulate(Message: buffer, PublicKey: buffer) -> (buffer?, buffer?)"})}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_1024encapsulatemessage-buffer-publickey-buffer---buffer-buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_1024.Encapsulate(Message: buffer, PublicKey: buffer) -> (buffer?, buffer?)"})}),"\n",(0,n.jsx)(r.p,{children:"Creates a ciphertext and shared secret using the recipient's public key."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-luau",children:"local Message = CSPRNG.RandomBytes(32)\nlocal Ciphertext, SharedSecret = MlKem.MLKEM_768.Encapsulate(Message, RecipientPublicKey)\nif Ciphertext and SharedSecret then\n    -- Send Ciphertext to recipient\n    -- Use SharedSecret for encryption\n    print(buffer.len(SharedSecret)) -- 32\nend\n"})}),"\n",(0,n.jsxs)(r.p,{children:["Returns ",(0,n.jsx)(r.code,{children:"nil, nil"})," if the public key is invalid."]}),"\n",(0,n.jsx)(r.h2,{id:"decapsulation",children:"Decapsulation"}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_512decapsulateciphertext-buffer-secretkey-buffer---buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_512.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -> buffer"})}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_768decapsulateciphertext-buffer-secretkey-buffer---buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_768.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -> buffer"})}),"\n",(0,n.jsx)(r.h3,{id:"mlkem_1024decapsulateciphertext-buffer-secretkey-buffer---buffer",children:(0,n.jsx)(r.code,{children:"MLKEM_1024.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -> buffer"})}),"\n",(0,n.jsx)(r.p,{children:"Recovers the shared secret using the secret key."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-luau",children:"local SharedSecret = MlKem.MLKEM_768.Decapsulate(Ciphertext, SecretKey)\nprint(buffer.len(SharedSecret)) -- 32\n\n-- SharedSecret matches what Encapsulate produced\n"})}),"\n",(0,n.jsx)(r.h2,{id:"kem-vs-dh",children:"KEM vs DH"}),"\n",(0,n.jsx)(r.p,{children:"Key Encapsulation Mechanisms work differently than Diffie Hellman:"}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Diffie Hellman (X25519)"})}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsx)(r.li,{children:"Alice and Bob exchange public keys"}),"\n",(0,n.jsx)(r.li,{children:"Both compute the same shared secret independently"}),"\n",(0,n.jsx)(r.li,{children:"Symmetric: either party can initiate"}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"KEM (ML KEM)"})}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsx)(r.li,{children:"Bob publishes his public key"}),"\n",(0,n.jsx)(r.li,{children:"Alice generates a random message and encapsulates it for Bob"}),"\n",(0,n.jsx)(r.li,{children:"Alice sends the ciphertext to Bob"}),"\n",(0,n.jsx)(r.li,{children:"Bob decapsulates to recover the shared secret"}),"\n",(0,n.jsx)(r.li,{children:"Asymmetric: Alice initiates, Bob receives"}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:"The KEM model maps naturally to how most protocols work anyway (client initiates connection to server)."}),"\n",(0,n.jsx)(r.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,n.jsx)(r.p,{children:"ML KEM is based on the hardness of the Module Learning With Errors (M LWE) problem. The encapsulation process generates a random message, encrypts it using the public key via a lattice based encryption scheme, and derives the final shared secret."}),"\n",(0,n.jsx)(r.p,{children:"The decapsulation process decrypts the ciphertext using the secret key, re encrypts the decrypted message and checks it matches, and if valid derives the shared secret the same way. If invalid, it derives a pseudorandom value (prevents leaking information about failures)."}),"\n",(0,n.jsx)(r.p,{children:"This re encryption check is an implicit rejection mechanism that provides IND CCA2 security."}),"\n",(0,n.jsx)(r.h2,{id:"examples",children:"Examples"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-luau",children:"-- Receiver generates keypair\nlocal PublicKey, SecretKey = MlKem.MLKEM_768.GenerateKeys()\n\n-- Sender encapsulates a shared secret\nlocal Message = CSPRNG.RandomBytes(32)\nlocal Ciphertext, SharedSecret = MlKem.MLKEM_768.Encapsulate(Message, PublicKey)\n\n-- Sender encrypts data with shared secret\nlocal Nonce = CSPRNG.RandomBytes(12)\nlocal EncryptedData, Tag = AEAD.Encrypt(Data, SharedSecret, Nonce)\n\n-- Send: Ciphertext, Nonce, EncryptedData, Tag\n\n-- Receiver decapsulates to get same shared secret\nlocal SharedSecret = MlKem.MLKEM_768.Decapsulate(Ciphertext, SecretKey)\n\n-- Receiver decrypts data\nlocal Data = AEAD.Decrypt(EncryptedData, SharedSecret, Nonce, Tag)\n"})}),"\n",(0,n.jsx)(l,{}),"\n",(0,n.jsx)(r.h2,{id:"when-to-use-ml-kem",children:"When to Use ML KEM"}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Use ML KEM when:"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"You need key exchange that survives quantum computers"}),"\n",(0,n.jsx)(r.li,{children:"Harvest now, decrypt later is a concern"}),"\n",(0,n.jsx)(r.li,{children:"Regulatory requirements mandate post quantum crypto"}),"\n",(0,n.jsx)(r.li,{children:"You are building long lived infrastructure"}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.strong,{children:"Stick with X25519 when:"})}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:"Bandwidth is constrained (ML KEM ciphertexts are 768 to 1568 bytes)"}),"\n",(0,n.jsx)(r.li,{children:"Performance is critical"}),"\n",(0,n.jsx)(r.li,{children:"You can migrate to post quantum later"}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"performance-notes",children:"Performance Notes"}),"\n",(0,n.jsx)(r.p,{children:"ML KEM is faster than X25519."}),"\n",(0,n.jsx)(r.p,{children:"The bigger concern is typically bandwidth rather than computation. Make sure your protocol can handle the larger key and ciphertext sizes."})]})}function b(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}}}]);