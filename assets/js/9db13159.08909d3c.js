"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[4437],{6483(e,n,r){r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>o,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"signatures/eddsa","title":"Ed25519 (EdDSA)","description":"Ed25519 is the modern standard for digital signatures. Fast, secure, and hard to mess up. Use this unless you need post quantum security.","source":"@site/docs/signatures/eddsa.md","sourceDirName":"signatures","slug":"/signatures/eddsa","permalink":"/docs/signatures/eddsa","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/signatures/eddsa.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Signatures and Key Exchange","permalink":"/docs/category/signatures-and-key-exchange"},"next":{"title":"X25519","permalink":"/docs/signatures/x25519"}}');var s=r(4848),t=r(8453);const a={sidebar_position:1},l="Ed25519 (EdDSA)",c={},d=[{value:"Key Generation",id:"key-generation",level:2},{value:"<code>EdDSA.PublicKey(SecretKey: buffer) -&gt; buffer</code>",id:"eddsapublickeysecretkey-buffer---buffer",level:3},{value:"Signing",id:"signing",level:2},{value:"<code>EdDSA.Sign(Message: buffer, SecretKey: buffer, PublicKey: buffer) -&gt; buffer</code>",id:"eddsasignmessage-buffer-secretkey-buffer-publickey-buffer---buffer",level:3},{value:"Verification",id:"verification",level:2},{value:"<code>EdDSA.Verify(Message: buffer, PublicKey: buffer, Signature: buffer) -&gt; boolean</code>",id:"eddsaverifymessage-buffer-publickey-buffer-signature-buffer---boolean",level:3},{value:"How It Works",id:"how-it-works",level:2},{value:"Security Properties",id:"security-properties",level:2},{value:"Examples",id:"examples",level:2},{value:"Sign then encrypt",id:"sign-then-encrypt",level:3},{value:"Public key authentication",id:"public-key-authentication",level:3}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"ed25519-eddsa",children:"Ed25519 (EdDSA)"})}),"\n",(0,s.jsx)(n.p,{children:"Ed25519 is the modern standard for digital signatures. Fast, secure, and hard to mess up. Use this unless you need post quantum security."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"local EdDSA = Cryptography.Verification.EdDSA\n"})}),"\n",(0,s.jsx)(n.h2,{id:"key-generation",children:"Key Generation"}),"\n",(0,s.jsx)(n.h3,{id:"eddsapublickeysecretkey-buffer---buffer",children:(0,s.jsx)(n.code,{children:"EdDSA.PublicKey(SecretKey: buffer) -> buffer"})}),"\n",(0,s.jsx)(n.p,{children:"Derives a 32 byte public key from a 32 byte secret key."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"local SecretKey = CSPRNG.Ed25519Random()\nlocal PublicKey = EdDSA.PublicKey(SecretKey)\n\nprint(buffer.len(SecretKey)) -- 32\nprint(buffer.len(PublicKey)) -- 32\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Always use ",(0,s.jsx)(n.code,{children:"CSPRNG.Ed25519Random()"})," to generate secret keys. It handles the clamping required by Ed25519 (clearing the lowest 3 bits, setting the highest bit, and so on)."]}),"\n",(0,s.jsx)(n.h2,{id:"signing",children:"Signing"}),"\n",(0,s.jsx)(n.h3,{id:"eddsasignmessage-buffer-secretkey-buffer-publickey-buffer---buffer",children:(0,s.jsx)(n.code,{children:"EdDSA.Sign(Message: buffer, SecretKey: buffer, PublicKey: buffer) -> buffer"})}),"\n",(0,s.jsx)(n.p,{children:"Creates a 64 byte signature."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:'local Message = buffer.fromstring("Sign this message")\nlocal Signature = EdDSA.Sign(Message, SecretKey, PublicKey)\n\nprint(buffer.len(Signature)) -- 64\n'})}),"\n",(0,s.jsx)(n.p,{children:"The signature is deterministic: signing the same message with the same key always produces the same signature. This eliminates an entire class of bugs related to bad randomness during signing (which has broken real world systems)."}),"\n",(0,s.jsx)(n.h2,{id:"verification",children:"Verification"}),"\n",(0,s.jsx)(n.h3,{id:"eddsaverifymessage-buffer-publickey-buffer-signature-buffer---boolean",children:(0,s.jsx)(n.code,{children:"EdDSA.Verify(Message: buffer, PublicKey: buffer, Signature: buffer) -> boolean"})}),"\n",(0,s.jsxs)(n.p,{children:["Returns ",(0,s.jsx)(n.code,{children:"true"})," if the signature is valid."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:'local IsValid = EdDSA.Verify(Message, PublicKey, Signature)\nif IsValid then\n    print("Signature verified")\nelse\n    warn("Invalid signature")\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsx)(n.p,{children:"Ed25519 uses the Edwards25519 curve (a twisted Edwards curve birationally equivalent to Curve25519) with SHA512 for internal hashing."}),"\n",(0,s.jsxs)(n.p,{children:["The implementation uses extended projective coordinates (X:Y:Z",":T",") for point representation, fixed window scalar multiplication, and precomputed tables for the base point."]}),"\n",(0,s.jsx)(n.p,{children:"Key sizes are small (32 bytes each for public and secret), signatures are compact (64 bytes), and operations are fast."}),"\n",(0,s.jsx)(n.h2,{id:"security-properties",children:"Security Properties"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Signature security level"})," Around 128 bits (breaking requires solving discrete log on a 255 bit curve)"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Deterministic signatures"})," No randomness needed during signing, eliminating nonce reuse vulnerabilities"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Malleability"})," Ed25519 signatures are slightly malleable (the same signature can have multiple valid representations). This does not affect security for most use cases, but matters if you are using signatures as unique identifiers."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Not quantum resistant"})," A sufficiently powerful quantum computer could break Ed25519 using Shor's algorithm. If you need post quantum security, use ML DSA instead."]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h3,{id:"sign-then-encrypt",children:"Sign then encrypt"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:"-- Sender signs, then encrypts\nlocal Signature = EdDSA.Sign(Message, SenderSecret, SenderPublic)\nlocal SignedMessage = buffer.create(buffer.len(Message) + 64)\nbuffer.copy(SignedMessage, 0, Message)\nbuffer.copy(SignedMessage, buffer.len(Message), Signature)\n\nlocal Ciphertext, Tag = AEAD.Encrypt(SignedMessage, SharedKey, Nonce)\n\n-- Receiver decrypts, then verifies\nlocal Decrypted = AEAD.Decrypt(Ciphertext, SharedKey, Nonce, Tag)\nlocal RecoveredMessage = buffer.create(buffer.len(Decrypted) - 64)\nlocal RecoveredSig = buffer.create(64)\nbuffer.copy(RecoveredMessage, 0, Decrypted, 0, buffer.len(Decrypted) - 64)\nbuffer.copy(RecoveredSig, 0, Decrypted, buffer.len(Decrypted) - 64, 64)\n\nlocal Valid = EdDSA.Verify(RecoveredMessage, SenderPublic, RecoveredSig)\n"})}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart LR\n    subgraph Sender\n        M[Message] --\x3e Sign\n        Sign --\x3e Combine[Message + Signature]\n        Combine --\x3e Encrypt\n    end\n    \n    Encrypt --\x3e|Ciphertext + Tag| Decrypt\n    \n    subgraph Receiver\n        Decrypt --\x3e Split[Split Message & Signature]\n        Split --\x3e Verify\n        Verify --\x3e Valid\n    end\n    \n    style M fill:#3c3c5a\n    style Sign fill:#3c3c5a\n    style Combine fill:#3c3c5a\n    style Encrypt fill:#503c50\n    style Decrypt fill:#503c50\n    style Split fill:#3c5a3c\n    style Verify fill:#3c5a3c\n    style Valid fill:#5a4632"}),"\n",(0,s.jsx)(n.h3,{id:"public-key-authentication",children:"Public key authentication"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-luau",children:'-- Server stores user public keys\nlocal UserPublicKeys = {\n    ["alice"] = AlicePublicKey,\n    ["bob"] = BobPublicKey,\n}\n\n-- Client signs request\nlocal Request = buffer.fromstring(\'{"action":"transfer","amount":103}\')\nlocal Signature = EdDSA.Sign(Request, ClientSecretKey, ClientPublicKey)\n\n-- Server verifies\nlocal function AuthenticateRequest(UserId, Request, Signature)\n    local PublicKey = UserPublicKeys[UserId]\n    if not PublicKey then return false end\n    return EdDSA.Verify(Request, PublicKey, Signature)\nend\n'})})]})}function o(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453(e,n,r){r.d(n,{R:()=>a,x:()=>l});var i=r(6540);const s={},t=i.createContext(s);function a(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);