"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[707],{2074(e,s,n){n.r(s),n.d(s,{assets:()=>h,contentTitle:()=>l,default:()=>d,frontMatter:()=>t,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"hashing/sha2","title":"SHA2","description":"The SHA2 family is the most used in modern cryptography. These are the hashes you will use most often.","source":"@site/docs/hashing/sha2.md","sourceDirName":"hashing","slug":"/hashing/sha2","permalink":"/docs/hashing/sha2","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/hashing/sha2.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Hashing","permalink":"/docs/category/hashing"},"next":{"title":"SHA3","permalink":"/docs/hashing/sha3"}}');var i=n(4848),r=n(8453);const t={sidebar_position:1},l="SHA2",h={},o=[{value:"SHA256",id:"sha256",level:2},{value:"<code>SHA256(Message: buffer) -&gt; (string, buffer)</code>",id:"sha256message-buffer---string-buffer",level:3},{value:"SHA224",id:"sha224",level:2},{value:"<code>SHA224(Message: buffer) -&gt; (string, buffer)</code>",id:"sha224message-buffer---string-buffer",level:3},{value:"SHA384",id:"sha384",level:2},{value:"<code>SHA384(Message: buffer) -&gt; (string, buffer)</code>",id:"sha384message-buffer---string-buffer",level:3},{value:"SHA512",id:"sha512",level:2},{value:"<code>SHA512(Message: buffer) -&gt; (string, buffer)</code>",id:"sha512message-buffer---string-buffer",level:3}];function c(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"sha2",children:"SHA2"})}),"\n",(0,i.jsx)(s.p,{children:"The SHA2 family is the most used in modern cryptography. These are the hashes you will use most often."}),"\n",(0,i.jsx)(s.h2,{id:"sha256",children:"SHA256"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-luau",children:"local SHA256 = Cryptography.Hashing.SHA2.SHA256\n"})}),"\n",(0,i.jsx)(s.h3,{id:"sha256message-buffer---string-buffer",children:(0,i.jsx)(s.code,{children:"SHA256(Message: buffer) -> (string, buffer)"})}),"\n",(0,i.jsx)(s.p,{children:"Computes a 256 bit (32 byte) hash. Returns both a hex string and the raw buffer."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-luau",children:'local Message = buffer.fromstring("Hello World")\nlocal HexDigest, RawDigest = SHA256(Message)\n\nprint(HexDigest) -- "a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e"\nprint(buffer.len(RawDigest)) -- 32\n'})}),"\n",(0,i.jsx)(s.p,{children:"SHA256 uses 64 rounds with 512 bit blocks. Collision resistance sits at 2^128, preimage resistance at 2^256. The implementation uses loop unrolling and bit32 operations for native compilation compatibility."}),"\n",(0,i.jsx)(s.p,{children:"Use it for data integrity checks, as a building block for signatures, or anywhere you need a solid general purpose hash."}),"\n",(0,i.jsx)(s.h2,{id:"sha224",children:"SHA224"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-luau",children:"local SHA224 = Cryptography.Hashing.SHA2.SHA224\n"})}),"\n",(0,i.jsx)(s.h3,{id:"sha224message-buffer---string-buffer",children:(0,i.jsx)(s.code,{children:"SHA224(Message: buffer) -> (string, buffer)"})}),"\n",(0,i.jsx)(s.p,{children:"Truncated SHA256 with different initial values. Outputs 224 bits (28 bytes)."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-luau",children:'local HexDigest, RawDigest = SHA224(buffer.fromstring("test"))\n'})}),"\n",(0,i.jsx)(s.p,{children:"Just use SHA256 unless you have a specific size requirement. The security margin difference is minimal and SHA256 is more widely supported."}),"\n",(0,i.jsx)(s.h2,{id:"sha384",children:"SHA384"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-luau",children:"local SHA384 = Cryptography.Hashing.SHA2.SHA384\n"})}),"\n",(0,i.jsx)(s.h3,{id:"sha384message-buffer---string-buffer",children:(0,i.jsx)(s.code,{children:"SHA384(Message: buffer) -> (string, buffer)"})}),"\n",(0,i.jsx)(s.p,{children:"Truncated SHA512 with different initial values. Outputs 384 bits (48 bytes)."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-luau",children:'local HexDigest, RawDigest = SHA384(buffer.fromstring("test"))\n'})}),"\n",(0,i.jsx)(s.p,{children:"A good middle ground when you need more bits than SHA256 but do not want the full 512."}),"\n",(0,i.jsx)(s.h2,{id:"sha512",children:"SHA512"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-luau",children:"local SHA512 = Cryptography.Hashing.SHA2.SHA512\n"})}),"\n",(0,i.jsx)(s.h3,{id:"sha512message-buffer---string-buffer",children:(0,i.jsx)(s.code,{children:"SHA512(Message: buffer) -> (string, buffer)"})}),"\n",(0,i.jsx)(s.p,{children:"The full 512 bit hash. 80 rounds, 1024 bit blocks."}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-luau",children:'local HexDigest, RawDigest = SHA512(buffer.fromstring("test"))\n'})}),"\n",(0,i.jsx)(s.p,{children:"On native 64 bit systems, SHA512 is actually faster than SHA256 because it uses 64 bit operations natively. In Luau this advantage is reduced since we emulate 64 bit math by splitting it into high/low words, but it is still fast. Ed25519 uses SHA512 internally for signature generation."})]})}function d(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453(e,s,n){n.d(s,{R:()=>t,x:()=>l});var a=n(6540);const i={},r=a.createContext(i);function t(e){const s=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),a.createElement(r.Provider,{value:s},e.children)}}}]);