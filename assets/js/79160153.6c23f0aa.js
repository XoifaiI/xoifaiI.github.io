"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[847],{4147(e,t,n){n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"encryption/aes","title":"AES GCM","description":"AES with Galois/Counter Mode. The standard for authenticated encryption.","source":"@site/docs/encryption/aes.md","sourceDirName":"encryption","slug":"/encryption/aes","permalink":"/docs/encryption/aes","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/encryption/aes.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"ChaCha20 Poly1305 (AEAD)","permalink":"/docs/encryption/aead"},"next":{"title":"Lightweight Ciphers","permalink":"/docs/encryption/lightweight"}}');var i=n(4848),s=n(8453);const a={sidebar_position:2},c="AES GCM",o={},d=[{value:"Encrypt",id:"encrypt",level:2},{value:"<code>AES.Encrypt(Plaintext: buffer, Key: buffer, IV: buffer, AAD: buffer?) -&gt; (buffer, buffer)</code>",id:"aesencryptplaintext-buffer-key-buffer-iv-buffer-aad-buffer---buffer-buffer",level:3},{value:"Decrypt",id:"decrypt",level:2},{value:"<code>AES.Decrypt(Ciphertext: buffer, Key: buffer, IV: buffer, Tag: buffer, AAD: buffer?) -&gt; (boolean, buffer?)</code>",id:"aesdecryptciphertext-buffer-key-buffer-iv-buffer-tag-buffer-aad-buffer---boolean-buffer",level:3},{value:"Key Sizes",id:"key-sizes",level:2},{value:"Security Limitations",id:"security-limitations",level:2},{value:"Nonce Size",id:"nonce-size",level:3},{value:"Not Key Committing",id:"not-key-committing",level:3},{value:"Timing Attacks",id:"timing-attacks",level:3},{value:"When to Use AES GCM",id:"when-to-use-aes-gcm",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"aes-gcm",children:"AES GCM"})}),"\n",(0,i.jsx)(t.p,{children:"AES with Galois/Counter Mode. The standard for authenticated encryption."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-luau",children:"local AES = Cryptography.Encryption.AES\n"})}),"\n",(0,i.jsx)(t.h2,{id:"encrypt",children:"Encrypt"}),"\n",(0,i.jsx)(t.h3,{id:"aesencryptplaintext-buffer-key-buffer-iv-buffer-aad-buffer---buffer-buffer",children:(0,i.jsx)(t.code,{children:"AES.Encrypt(Plaintext: buffer, Key: buffer, IV: buffer, AAD: buffer?) -> (buffer, buffer)"})}),"\n",(0,i.jsx)(t.p,{children:"Encrypts data and returns ciphertext plus a 16 byte authentication tag."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Type"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Plaintext"}),(0,i.jsx)(t.td,{children:"buffer"}),(0,i.jsx)(t.td,{children:"Data to encrypt"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Key"}),(0,i.jsx)(t.td,{children:"buffer"}),(0,i.jsx)(t.td,{children:"16, 24, or 32 bytes (AES 128/192/256)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"IV"}),(0,i.jsx)(t.td,{children:"buffer"}),(0,i.jsx)(t.td,{children:"12 bytes recommended"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"AAD"}),(0,i.jsx)(t.td,{children:"buffer?"}),(0,i.jsx)(t.td,{children:"Additional authenticated data (optional)"})]})]})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-luau",children:'local Key = CSPRNG.RandomBytes(32) -- AES 256\nlocal IV = CSPRNG.RandomBytes(12)\nlocal Plaintext = buffer.fromstring("Secret data")\n\nlocal Ciphertext, Tag = AES.Encrypt(Plaintext, Key, IV)\n\n-- With AAD\nlocal AAD = buffer.fromstring("metadata")\nlocal Ciphertext2, Tag2 = AES.Encrypt(Plaintext, Key, IV, AAD)\n'})}),"\n",(0,i.jsx)(t.h2,{id:"decrypt",children:"Decrypt"}),"\n",(0,i.jsx)(t.h3,{id:"aesdecryptciphertext-buffer-key-buffer-iv-buffer-tag-buffer-aad-buffer---boolean-buffer",children:(0,i.jsx)(t.code,{children:"AES.Decrypt(Ciphertext: buffer, Key: buffer, IV: buffer, Tag: buffer, AAD: buffer?) -> (boolean, buffer?)"})}),"\n",(0,i.jsxs)(t.p,{children:["Returns a success boolean and the decrypted data (or ",(0,i.jsx)(t.code,{children:"nil"})," on failure)."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-luau",children:'local Success, Decrypted = AES.Decrypt(Ciphertext, Key, IV, Tag, AAD)\nif Success then\n    print("Decrypted:", buffer.tostring(Decrypted))\nelse\n    warn("Decryption failed, authentication error")\nend\n'})}),"\n",(0,i.jsx)(t.p,{children:"The return signature is different from AEAD. You get an explicit boolean instead of checking for nil."}),"\n",(0,i.jsx)(t.h2,{id:"key-sizes",children:"Key Sizes"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Key Size"}),(0,i.jsx)(t.th,{children:"Variant"}),(0,i.jsx)(t.th,{children:"Rounds"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"16 bytes"}),(0,i.jsx)(t.td,{children:"AES 128"}),(0,i.jsx)(t.td,{children:"10"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"24 bytes"}),(0,i.jsx)(t.td,{children:"AES 192"}),(0,i.jsx)(t.td,{children:"12"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"32 bytes"}),(0,i.jsx)(t.td,{children:"AES 256"}),(0,i.jsx)(t.td,{children:"14"})]})]})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-luau",children:"local Key128 = CSPRNG.RandomBytes(16)\nlocal Key192 = CSPRNG.RandomBytes(24)\nlocal Key256 = CSPRNG.RandomBytes(32)\n"})}),"\n",(0,i.jsx)(t.p,{children:"For new applications, use AES 256 unless you have specific performance constraints."}),"\n",(0,i.jsx)(t.h2,{id:"security-limitations",children:"Security Limitations"}),"\n",(0,i.jsx)(t.p,{children:"AES GCM has some important limitations you should understand."}),"\n",(0,i.jsx)(t.h3,{id:"nonce-size",children:"Nonce Size"}),"\n",(0,i.jsx)(t.p,{children:"The 96 bit (12 byte) IV means you hit birthday bound concerns around 2^32 messages with the same key. After about 4 billion encryptions, you have a non negligible chance of IV collision. Rotate keys before you get anywhere near this limit."}),"\n",(0,i.jsx)(t.p,{children:"Unlike ChaCha20 Poly1305, there is no built in extended nonce variant. If you need to encrypt many messages with the same key, consider using a counter based IV scheme, rotating keys frequently, or using ChaCha20 Poly1305 with XChaCha20 mode instead."}),"\n",(0,i.jsx)(t.h3,{id:"not-key-committing",children:"Not Key Committing"}),"\n",(0,i.jsx)(t.p,{children:"AES GCM is not key committing. This means the same ciphertext could potentially decrypt to valid (but different) plaintexts under different keys. An attacker who can choose ciphertext might find a collision where two different keys both produce valid decryptions."}),"\n",(0,i.jsx)(t.p,{children:"This enables the Invisible Salamander attack: in a group messaging scenario, an attacker could craft a message that appears benign to moderators (using one key) but malicious to recipients (using another key)."}),"\n",(0,i.jsx)(t.p,{children:"If key commitment matters for your use case, include a hash or commitment of the key in your AAD, use a key committing AEAD construction, or verify the key through an independent channel."}),"\n",(0,i.jsx)(t.h3,{id:"timing-attacks",children:"Timing Attacks"}),"\n",(0,i.jsx)(t.p,{children:"The S box lookups in AES are theoretically vulnerable to cache timing attacks. In native implementations this is addressed with constant time table lookups or AES NI instructions. In Luau, we cannot guarantee constant time behavior, but practical exploitation in Roblox's environment is extremely difficult due to network jitter and the inability to make precise timing measurements."}),"\n",(0,i.jsx)(t.h2,{id:"when-to-use-aes-gcm",children:"When to Use AES GCM"}),"\n",(0,i.jsx)(t.p,{children:"Use AES GCM when you need compatibility with existing AES GCM systems, standards or regulations require AES specifically, or you are interfacing with hardware that has AES acceleration."}),"\n",(0,i.jsx)(t.p,{children:"For new Roblox specific implementations, ChaCha20 Poly1305 is generally preferred because it is faster in pure software (no AES NI in Luau), XChaCha20 gives you larger nonces, and there are no table lookup timing concerns."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453(e,t,n){n.d(t,{R:()=>a,x:()=>c});var r=n(6540);const i={},s=r.createContext(i);function a(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);