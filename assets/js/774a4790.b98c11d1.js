"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[188],{5014(e,n,t){t.d(n,{A:()=>u,W:()=>s});var r=t(6540),a=t(5622),i=t(5293),o=(t(1388),t(4848));function s(e,n,t){return{id:e,source:n,target:t,type:"smoothstep",animated:!0}}const c=e=>({background:e,color:"#fff",border:"none",borderRadius:8,fontSize:14,padding:"10px 20px"}),d={padding:.2,minZoom:.1,maxZoom:1};function l({nodes:e,edges:n,verticalNodes:t,verticalEdges:s}){const{colorMode:l}=(0,i.G)(),u="dark"===l,{fitView:h}=(0,a.VH)(),f=(0,r.useRef)(null),[y,p]=(0,r.useState)(!1);(0,r.useEffect)(()=>{if(!f.current)return;const e=new ResizeObserver(e=>{const n=e[0]?.contentRect.width??0;p(n<468),requestAnimationFrame(()=>{h(d)})});return e.observe(f.current),()=>e.disconnect()},[h]);const b=y&&t&&s,x=b?t:e,m=b?s:n;(0,r.useEffect)(()=>{requestAnimationFrame(()=>{h(d)})},[x,u,h]);const g=(0,r.useMemo)(()=>x(c,u),[x,u]);return(0,o.jsx)("div",{ref:f,style:{width:"100%",height:"100%"},children:(0,o.jsx)(a.Gc,{nodes:g,edges:m,fitView:!0,fitViewOptions:d,minZoom:.1,preventScrolling:!1,nodesDraggable:!1,nodesConnectable:!1,elementsSelectable:!1,proOptions:{hideAttribution:!0}})})}function u({nodes:e,edges:n,verticalNodes:t,verticalEdges:r,className:i}){return(0,o.jsx)("div",{className:i,children:(0,o.jsx)(a.Ln,{children:(0,o.jsx)(l,{nodes:e,edges:n,verticalNodes:t,verticalEdges:r})})})}},8737(e,n,t){t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>y,default:()=>m,frontMatter:()=>f,metadata:()=>r,toc:()=>b});const r=JSON.parse('{"id":"encryption/aead","title":"ChaCha20 Poly1305 (AEAD)","description":"This is what you should use for symmetric encryption. It is authenticated encryption with associated data (AEAD), meaning tampered ciphertext will fail to decrypt. You get confidentiality and integrity in one package.","source":"@site/docs/encryption/aead.md","sourceDirName":"encryption","slug":"/encryption/aead","permalink":"/docs/encryption/aead","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/encryption/aead.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Encryption","permalink":"/docs/category/encryption"},"next":{"title":"AES GCM","permalink":"/docs/encryption/aes"}}');var a=t(4848),i=t(8453),o=t(5622),s=t(5014);const c=(e,n)=>[{id:"plaintext",position:{x:0,y:0},data:{label:"Plaintext"},style:e(n?"#6366f1":"#818cf8"),sourcePosition:o.yX.Right},{id:"key",position:{x:0,y:70},data:{label:"Key"},style:e(n?"#22c55e":"#4ade80"),sourcePosition:o.yX.Right},{id:"nonce",position:{x:0,y:140},data:{label:"Nonce"},style:e(n?"#22c55e":"#4ade80"),sourcePosition:o.yX.Right},{id:"encrypt",position:{x:220,y:70},data:{label:"AEAD.Encrypt"},style:e(n?"#8b5cf6":"#a78bfa"),targetPosition:o.yX.Left,sourcePosition:o.yX.Right},{id:"output",position:{x:440,y:70},data:{label:"Ciphertext + Tag"},style:e(n?"#f59e0b":"#fbbf24"),targetPosition:o.yX.Left}],d=[(0,s.W)("e1","plaintext","encrypt"),(0,s.W)("e2","key","encrypt"),(0,s.W)("e3","nonce","encrypt"),(0,s.W)("e4","encrypt","output")],l=(e,n)=>[{id:"plaintext",position:{x:0,y:0},data:{label:"Plaintext"},style:e(n?"#6366f1":"#818cf8"),sourcePosition:o.yX.Bottom},{id:"key",position:{x:140,y:0},data:{label:"Key"},style:e(n?"#22c55e":"#4ade80"),sourcePosition:o.yX.Bottom},{id:"nonce",position:{x:280,y:0},data:{label:"Nonce"},style:e(n?"#22c55e":"#4ade80"),sourcePosition:o.yX.Bottom},{id:"encrypt",position:{x:110,y:80},data:{label:"AEAD.Encrypt"},style:e(n?"#8b5cf6":"#a78bfa"),targetPosition:o.yX.Top,sourcePosition:o.yX.Bottom},{id:"output",position:{x:80,y:160},data:{label:"Ciphertext + Tag"},style:e(n?"#f59e0b":"#fbbf24"),targetPosition:o.yX.Top}],u=[(0,s.W)("e1","plaintext","encrypt"),(0,s.W)("e2","key","encrypt"),(0,s.W)("e3","nonce","encrypt"),(0,s.W)("e4","encrypt","output")];function h(){return(0,a.jsx)(s.A,{className:"reactflow-wrapper",nodes:c,edges:d,verticalNodes:l,verticalEdges:u})}const f={sidebar_position:1},y="ChaCha20 Poly1305 (AEAD)",p={},b=[{value:"Encrypt",id:"encrypt",level:2},{value:"<code>AEAD.Encrypt(Message: buffer, Key: buffer, Nonce: buffer, AAD: buffer?, Rounds: number?, UseXChaCha20: boolean?) -&gt; (buffer, buffer)</code>",id:"aeadencryptmessage-buffer-key-buffer-nonce-buffer-aad-buffer-rounds-number-usexchacha20-boolean---buffer-buffer",level:3},{value:"Decrypt",id:"decrypt",level:2},{value:"<code>AEAD.Decrypt(Ciphertext: buffer, Key: buffer, Nonce: buffer, Tag: buffer, AAD: buffer?, Rounds: number?, UseXChaCha20: boolean?) -&gt; buffer?</code>",id:"aeaddecryptciphertext-buffer-key-buffer-nonce-buffer-tag-buffer-aad-buffer-rounds-number-usexchacha20-boolean---buffer",level:3},{value:"XChaCha20 Mode",id:"xchacha20-mode",level:2},{value:"Reduced Rounds",id:"reduced-rounds",level:2},{value:"Raw Stream Ciphers",id:"raw-stream-ciphers",level:2},{value:"<code>AEAD.ChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?) -&gt; buffer</code>",id:"aeadchacha20data-buffer-key-buffer-nonce-buffer-counter-number-rounds-number---buffer",level:3},{value:"<code>AEAD.XChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?) -&gt; buffer</code>",id:"aeadxchacha20data-buffer-key-buffer-nonce-buffer-counter-number-rounds-number---buffer",level:3},{value:"Security Properties",id:"security-properties",level:2}];function x(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"chacha20-poly1305-aead",children:"ChaCha20 Poly1305 (AEAD)"})}),"\n","\n",(0,a.jsx)(n.p,{children:"This is what you should use for symmetric encryption. It is authenticated encryption with associated data (AEAD), meaning tampered ciphertext will fail to decrypt. You get confidentiality and integrity in one package."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:"local AEAD = Cryptography.Encryption.AEAD\n"})}),"\n",(0,a.jsx)(n.h2,{id:"encrypt",children:"Encrypt"}),"\n",(0,a.jsx)(n.h3,{id:"aeadencryptmessage-buffer-key-buffer-nonce-buffer-aad-buffer-rounds-number-usexchacha20-boolean---buffer-buffer",children:(0,a.jsx)(n.code,{children:"AEAD.Encrypt(Message: buffer, Key: buffer, Nonce: buffer, AAD: buffer?, Rounds: number?, UseXChaCha20: boolean?) -> (buffer, buffer)"})}),"\n",(0,a.jsx)(n.p,{children:"Encrypts data and returns ciphertext plus a 16 byte authentication tag."}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Parameter"}),(0,a.jsx)(n.th,{children:"Type"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Message"}),(0,a.jsx)(n.td,{children:"buffer"}),(0,a.jsx)(n.td,{children:"Data to encrypt"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Key"}),(0,a.jsx)(n.td,{children:"buffer"}),(0,a.jsxs)(n.td,{children:["32 bytes, use ",(0,a.jsx)(n.code,{children:"CSPRNG.RandomBytes(32)"})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Nonce"}),(0,a.jsx)(n.td,{children:"buffer"}),(0,a.jsx)(n.td,{children:"12 bytes for ChaCha20, 24 bytes for XChaCha20"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"AAD"}),(0,a.jsx)(n.td,{children:"buffer?"}),(0,a.jsx)(n.td,{children:"Additional authenticated data (optional)"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Rounds"}),(0,a.jsx)(n.td,{children:"number?"}),(0,a.jsx)(n.td,{children:"Default 20, can use 12 or 8 for speed"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"UseXChaCha20"}),(0,a.jsx)(n.td,{children:"boolean?"}),(0,a.jsx)(n.td,{children:"Use extended nonce variant"})]})]})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:'local Key = CSPRNG.RandomBytes(32)\nlocal Nonce = CSPRNG.RandomBytes(12)\nlocal Plaintext = buffer.fromstring("Secret message")\n\n-- Basic encryption\nlocal Ciphertext, Tag = AEAD.Encrypt(Plaintext, Key, Nonce)\n\n-- With additional authenticated data\nlocal AAD = buffer.fromstring("user:alice,timestamp:12345")\nlocal Ciphertext2, Tag2 = AEAD.Encrypt(Plaintext, Key, Nonce, AAD)\n'})}),"\n",(0,a.jsx)(n.p,{children:"The AAD is authenticated but not encrypted. Use it for metadata you want to verify (like headers or routing info) but do not need to hide."}),"\n",(0,a.jsx)(n.h2,{id:"decrypt",children:"Decrypt"}),"\n",(0,a.jsx)(n.h3,{id:"aeaddecryptciphertext-buffer-key-buffer-nonce-buffer-tag-buffer-aad-buffer-rounds-number-usexchacha20-boolean---buffer",children:(0,a.jsx)(n.code,{children:"AEAD.Decrypt(Ciphertext: buffer, Key: buffer, Nonce: buffer, Tag: buffer, AAD: buffer?, Rounds: number?, UseXChaCha20: boolean?) -> buffer?"})}),"\n",(0,a.jsxs)(n.p,{children:["Decrypts and verifies. Returns ",(0,a.jsx)(n.code,{children:"nil"})," if authentication fails."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:'local Decrypted = AEAD.Decrypt(Ciphertext, Key, Nonce, Tag, AAD)\nif Decrypted then\n    print("Decrypted:", buffer.tostring(Decrypted))\nelse\n    warn("Authentication failed, data was tampered")\nend\n'})}),"\n",(0,a.jsx)(h,{}),"\n",(0,a.jsx)(n.admonition,{title:"Always Check for nil",type:"warning",children:(0,a.jsxs)(n.p,{children:["If ",(0,a.jsx)(n.code,{children:"Decrypt"})," returns ",(0,a.jsx)(n.code,{children:"nil"}),", the ciphertext was modified or the wrong key/nonce was used. Never try to use the data."]})}),"\n",(0,a.jsx)(n.h2,{id:"xchacha20-mode",children:"XChaCha20 Mode"}),"\n",(0,a.jsx)(n.p,{children:"Standard ChaCha20 uses a 96 bit nonce, which has a birthday bound around 2^32 messages with the same key. If you are encrypting a lot of messages or want to use random nonces without worrying, use XChaCha20 with its 192 bit nonce:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:"local Key = CSPRNG.RandomBytes(32)\nlocal Nonce = CSPRNG.RandomBytes(24) -- 24 bytes for XChaCha20\n\nlocal Ciphertext, Tag = AEAD.Encrypt(Plaintext, Key, Nonce, nil, nil, true)\nlocal Decrypted = AEAD.Decrypt(Ciphertext, Key, Nonce, Tag, nil, nil, true)\n"})}),"\n",(0,a.jsx)(n.p,{children:"XChaCha20 uses HChaCha20 to derive a subkey from the first 128 bits of the nonce, giving you essentially unlimited messages per key without birthday concerns."}),"\n",(0,a.jsx)(n.h2,{id:"reduced-rounds",children:"Reduced Rounds"}),"\n",(0,a.jsx)(n.p,{children:"The default 20 rounds provide a large security margin. If you need more speed and can accept a smaller margin:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:"-- 12 rounds (ChaCha12), still considered secure\nlocal Ciphertext, Tag = AEAD.Encrypt(Plaintext, Key, Nonce, nil, 12)\n\n-- 8 rounds (ChaCha8), minimal security margin\nlocal Ciphertext, Tag = AEAD.Encrypt(Plaintext, Key, Nonce, nil, 8)\n"})}),"\n",(0,a.jsx)(n.p,{children:"For most applications, stick with 20 rounds. The performance difference in Luau is not dramatic enough to justify reduced security margin."}),"\n",(0,a.jsx)(n.h2,{id:"raw-stream-ciphers",children:"Raw Stream Ciphers"}),"\n",(0,a.jsx)(n.p,{children:"If you need just the stream cipher without Poly1305 authentication:"}),"\n",(0,a.jsx)(n.h3,{id:"aeadchacha20data-buffer-key-buffer-nonce-buffer-counter-number-rounds-number---buffer",children:(0,a.jsx)(n.code,{children:"AEAD.ChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?) -> buffer"})}),"\n",(0,a.jsx)(n.h3,{id:"aeadxchacha20data-buffer-key-buffer-nonce-buffer-counter-number-rounds-number---buffer",children:(0,a.jsx)(n.code,{children:"AEAD.XChaCha20(Data: buffer, Key: buffer, Nonce: buffer, Counter: number?, Rounds: number?) -> buffer"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-luau",children:"local Encrypted = AEAD.ChaCha20(Data, Key, Nonce, 1, 20)\nlocal Decrypted = AEAD.ChaCha20(Encrypted, Key, Nonce, 1, 20)\n"})}),"\n",(0,a.jsx)(n.admonition,{title:"No Authentication",type:"danger",children:(0,a.jsx)(n.p,{children:"These raw functions do not authenticate. An attacker can flip bits in your ciphertext and you will not know. Only use these if you have a separate authentication mechanism."})}),"\n",(0,a.jsx)(n.h2,{id:"security-properties",children:"Security Properties"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"What AEAD gives you:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Confidentiality: attacker cannot read the plaintext"}),"\n",(0,a.jsx)(n.li,{children:"Integrity: attacker cannot modify ciphertext without detection"}),"\n",(0,a.jsx)(n.li,{children:"Authenticity: ciphertext was created by someone with the key"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"What AEAD does not give you:"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Key commitment"})," The same ciphertext can potentially decrypt to different plaintexts under different keys. This matters in multi key scenarios where an attacker might try to find a key that decrypts malicious content to something benign (Invisible Salamander attack). If this is a concern, include a hash of the key in your AAD."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Nonce misuse resistance"})," Reusing a nonce with the same key is catastrophic. It leaks the XOR of plaintexts and breaks authentication. Use random nonces with XChaCha20 if you cannot guarantee uniqueness."]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(x,{...e})}):x(e)}}}]);