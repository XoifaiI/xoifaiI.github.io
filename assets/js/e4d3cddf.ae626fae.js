"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[864],{2975(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"best-practices","title":"Security Best Practices","description":"A condensed guide to using this library safely.","source":"@site/docs/best-practices.md","sourceDirName":".","slug":"/best-practices","permalink":"/docs/best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/best-practices.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/intro"},"next":{"title":"Hashing","permalink":"/docs/category/hashing"}}');var i=t(4848),s=t(8453);const c={sidebar_position:2},a="Security Best Practices",l={},o=[{value:"Key Management",id:"key-management",level:2},{value:"Nonce and IV Handling",id:"nonce-and-iv-handling",level:2},{value:"Algorithm Selection",id:"algorithm-selection",level:2},{value:"Hashing",id:"hashing",level:3},{value:"Symmetric Encryption",id:"symmetric-encryption",level:3},{value:"Signatures",id:"signatures",level:3},{value:"Key Exchange",id:"key-exchange",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Comparing secrets incorrectly",id:"comparing-secrets-incorrectly",level:3},{value:"Using encryption without authentication",id:"using-encryption-without-authentication",level:3},{value:"Trusting client provided crypto",id:"trusting-client-provided-crypto",level:3},{value:"Forgetting that encryption is not authentication",id:"forgetting-that-encryption-is-not-authentication",level:3},{value:"What the Library Cannot Protect Against",id:"what-the-library-cannot-protect-against",level:2},{value:"Quick Checklist",id:"quick-checklist",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"security-best-practices",children:"Security Best Practices"})}),"\n",(0,i.jsx)(n.p,{children:"A condensed guide to using this library safely."}),"\n",(0,i.jsx)(n.h2,{id:"key-management",children:"Key Management"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Generate keys properly"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:'-- Correct\nlocal Key = CSPRNG.RandomBytes(32)\nlocal EdKey = CSPRNG.Ed25519Random()\n\n-- Wrong\nlocal Key = buffer.fromstring("mysecretpassword") -- predictable\nlocal BadKey = buffer.create(32) -- all zeros\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Never hardcode keys."})," Use Roblox Secrets for server side keys:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:'local SecretKey = game:GetService("HttpService"):GetSecret("ENCRYPTION_KEY")\n-- Can\'t use secret data type with buffers though\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Rotate keys periodically."})," Fresh keys limit damage from unknown compromises."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use different keys for different purposes"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:'local Context = buffer.fromstring("MyApp encryption key")\nlocal KeyDeriver = Blake3.DeriveKey(Context)\n\nlocal MasterSecret = CSPRNG.RandomBytes(32)\nlocal EncryptionKey = KeyDeriver(MasterSecret, 32)\n\nlocal MacContext = buffer.fromstring("MyApp mac key")\nlocal MacDeriver = Blake3.DeriveKey(MacContext)\nlocal MacKey = MacDeriver(MasterSecret, 32)\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Never expose keys to clients."})," If the client needs to encrypt something, they should not have the key the server uses."]}),"\n",(0,i.jsx)(n.h2,{id:"nonce-and-iv-handling",children:"Nonce and IV Handling"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"The cardinal rule: never reuse a nonce with the same key."})}),"\n",(0,i.jsx)(n.p,{children:"With ChaCha20 Poly1305, reusing a nonce leaks the XOR of plaintexts, allows forgery of authentication tags, and completely breaks security."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:'-- Correct: random nonces\nlocal Nonce = CSPRNG.RandomBytes(12)\n\n-- Correct: counter based nonces\nlocal Counter = 0\nlocal function GetNonce()\n    Counter += 1\n    local Nonce = buffer.create(12)\n    buffer.writeu32(Nonce, 0, Counter)\n    return Nonce\nend\n\n-- Wrong: reusing nonces\nlocal StaticNonce = buffer.fromstring("fixednonce12")\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"For high volume encryption, use XChaCha20"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:"-- 24 byte nonces have negligible collision probability\nlocal Nonce = CSPRNG.RandomBytes(24)\nlocal Ciphertext, Tag = AEAD.Encrypt(Data, Key, Nonce, nil, nil, true)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"AES GCM has a 2^32 message limit"})," per key with random 96 bit IVs. Rotate keys before approaching this."]}),"\n",(0,i.jsx)(n.h2,{id:"algorithm-selection",children:"Algorithm Selection"}),"\n",(0,i.jsx)(n.h3,{id:"hashing",children:"Hashing"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Use Case"}),(0,i.jsx)(n.th,{children:"Algorithm"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"General purpose"}),(0,i.jsx)(n.td,{children:"SHA256 or BLAKE3"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Speed critical"}),(0,i.jsx)(n.td,{children:"BLAKE3"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Regulatory compliance"}),(0,i.jsx)(n.td,{children:"SHA256 or SHA3 256"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Key derivation"}),(0,i.jsx)(n.td,{children:"BLAKE3.DeriveKey"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"symmetric-encryption",children:"Symmetric Encryption"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Use Case"}),(0,i.jsx)(n.th,{children:"Algorithm"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"General purpose"}),(0,i.jsx)(n.td,{children:"ChaCha20 Poly1305 (AEAD)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"AES compatibility required"}),(0,i.jsx)(n.td,{children:"AES GCM"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Many messages per key"}),(0,i.jsx)(n.td,{children:"XChaCha20 Poly1305"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"signatures",children:"Signatures"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Use Case"}),(0,i.jsx)(n.th,{children:"Algorithm"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"General purpose"}),(0,i.jsx)(n.td,{children:"Ed25519"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Post quantum security"}),(0,i.jsx)(n.td,{children:"ML DSA"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Both (paranoid)"}),(0,i.jsx)(n.td,{children:"Ed25519 + ML DSA"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"key-exchange",children:"Key Exchange"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Use Case"}),(0,i.jsx)(n.th,{children:"Algorithm"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"General purpose"}),(0,i.jsx)(n.td,{children:"X25519"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Post quantum security"}),(0,i.jsx)(n.td,{children:"ML KEM"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Both (paranoid)"}),(0,i.jsx)(n.td,{children:"X25519 + ML KEM hybrid"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,i.jsx)(n.h3,{id:"comparing-secrets-incorrectly",children:"Comparing secrets incorrectly"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:"-- Wrong: timing attack possible\nif HexMac == ExpectedMac then\n\n-- Correct: constant time comparison\nlocal function ConstantTimeCompare(a, b)\n    if buffer.len(a) ~= buffer.len(b) then return false end\n    local diff = 0\n    for i = 0, buffer.len(a) - 1 do\n        diff = bit32.bor(diff, bit32.bxor(buffer.readu8(a, i), buffer.readu8(b, i)))\n    end\n    return diff == 0\nend\n"})}),"\n",(0,i.jsx)(n.p,{children:"The library's internal comparisons are constant time, but be careful when writing your own verification logic."}),"\n",(0,i.jsx)(n.h3,{id:"using-encryption-without-authentication",children:"Using encryption without authentication"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:"-- Wrong: raw ChaCha20 without Poly1305\nlocal Encrypted = AEAD.ChaCha20(Data, Key, Nonce)\n-- attacker can flip bits undetected\n\n-- Correct: authenticated encryption\nlocal Ciphertext, Tag = AEAD.Encrypt(Data, Key, Nonce)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"trusting-client-provided-crypto",children:"Trusting client provided crypto"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:"-- Wrong: client sends encrypted data with their own key\nRemoteEvent.OnServerEvent:Connect(function(player, encryptedData, clientKey)\n    local decrypted = AEAD.Decrypt(encryptedData, clientKey, ...) -- pointless\nend)\n\n-- Correct: server controls the keys\nRemoteEvent.OnServerEvent:Connect(function(player, encryptedData, nonce, tag)\n    local decrypted = AEAD.Decrypt(encryptedData, ServerKey, nonce, tag)\nend)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"forgetting-that-encryption-is-not-authentication",children:"Forgetting that encryption is not authentication"}),"\n",(0,i.jsx)(n.p,{children:"Encryption hides content. It does not prove who sent it. If you need to know the sender, use signatures or MACs."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:"-- Encrypt for confidentiality\nlocal Ciphertext, Tag = AEAD.Encrypt(Message, SharedKey, Nonce)\n\n-- Sign for authenticity\nlocal Signature = EdDSA.Sign(Message, SenderPrivate, SenderPublic)\n"})}),"\n",(0,i.jsx)(n.h2,{id:"what-the-library-cannot-protect-against",children:"What the Library Cannot Protect Against"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Side channels"})," Luau execution timing is not constant. The library uses constant time operations where feasible, but the VM's behavior is not guaranteed."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Memory exposure"})," Buffers persist until garbage collection. Zeroing them helps but does not guarantee the memory is overwritten before being reallocated."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key compromise"})," If someone gets your key, they get your data."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Protocol bugs"})," The primitives are solid, but combining them incorrectly breaks security. AEAD without unique nonces, signatures without verifying the public key source, and so on."]}),"\n",(0,i.jsx)(n.h2,{id:"quick-checklist",children:"Quick Checklist"}),"\n",(0,i.jsx)(n.p,{children:"Before releasing:"}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All keys generated with CSPRNG"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","No hardcoded keys in source"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Nonces are unique per message"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Using authenticated encryption (AEAD or AES GCM)"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Signatures verified before trusting data"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Keys not exposed to clients"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Error handling does not leak information"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Tested with invalid inputs"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>c,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function c(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);