"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[741],{3075(e,r,t){t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"encryption/lightweight","title":"Lightweight Ciphers","description":"These exist for specific use cases where you need something simple and fast. They come with tradeoffs you need to understand.","source":"@site/docs/encryption/lightweight.md","sourceDirName":"encryption","slug":"/encryption/lightweight","permalink":"/docs/encryption/lightweight","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/encryption/lightweight.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"AES GCM","permalink":"/docs/encryption/aes"},"next":{"title":"Signatures and Key Exchange","permalink":"/docs/category/signatures-and-key-exchange"}}');var i=t(4848),s=t(8453);const c={sidebar_position:3},d="Lightweight Ciphers",l={},o=[{value:"XOR",id:"xor",level:2},{value:"<code>XOR(Data: buffer, Key: buffer) -&gt; buffer</code>",id:"xordata-buffer-key-buffer---buffer",level:3},{value:"Simon",id:"simon",level:2},{value:"<code>Simon.Encrypt(PlaintextBuffer: buffer, KeyBuffer: buffer) -&gt; buffer</code>",id:"simonencryptplaintextbuffer-buffer-keybuffer-buffer---buffer",level:3},{value:"<code>Simon.Decrypt(CipherBuffer: buffer, KeyBuffer: buffer) -&gt; buffer</code>",id:"simondecryptcipherbuffer-buffer-keybuffer-buffer---buffer",level:3},{value:"Speck",id:"speck",level:2},{value:"<code>Speck.Encrypt(PlaintextBuffer: buffer, KeyBuffer: buffer) -&gt; buffer</code>",id:"speckencryptplaintextbuffer-buffer-keybuffer-buffer---buffer",level:3},{value:"<code>Speck.Decrypt(CipherBuffer: buffer, KeyBuffer: buffer) -&gt; buffer</code>",id:"speckdecryptcipherbuffer-buffer-keybuffer-buffer---buffer",level:3},{value:"Simon vs Speck",id:"simon-vs-speck",level:2},{value:"When to Use These",id:"when-to-use-these",level:2}];function a(e){const r={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"lightweight-ciphers",children:"Lightweight Ciphers"})}),"\n",(0,i.jsx)(r.p,{children:"These exist for specific use cases where you need something simple and fast. They come with tradeoffs you need to understand."}),"\n",(0,i.jsx)(r.h2,{id:"xor",children:"XOR"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-luau",children:"local XOR = Cryptography.Encryption.XOR\n"})}),"\n",(0,i.jsx)(r.h3,{id:"xordata-buffer-key-buffer---buffer",children:(0,i.jsx)(r.code,{children:"XOR(Data: buffer, Key: buffer) -> buffer"})}),"\n",(0,i.jsx)(r.p,{children:"Simple XOR cipher. Encryption and decryption are the same operation."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-luau",children:'local Key = buffer.fromstring("MySecretKey12345")\nlocal Encrypted = XOR(buffer.fromstring("Hello"), Key)\nlocal Decrypted = XOR(Encrypted, Key)\nprint(buffer.tostring(Decrypted)) -- "Hello"\n'})}),"\n",(0,i.jsx)(r.p,{children:"The implementation handles keys of any length by repeating them. Keys that are multiples of 4 bytes are fastest due to 32 bit word operations."}),"\n",(0,i.jsxs)(r.admonition,{title:"Only Secure as a One Time Pad",type:"danger",children:[(0,i.jsxs)(r.p,{children:["XOR is only secure if the key is truly random (from CSPRNG, not ",(0,i.jsx)(r.code,{children:"math.random"}),"), the key is at least as long as the message, and the key is never reused."]}),(0,i.jsxs)(r.p,{children:["Reusing a key leaks ",(0,i.jsx)(r.code,{children:"plaintext1 XOR plaintext2"}),", which is often enough to recover both plaintexts. In practice, this means XOR is almost never the right choice. Use AEAD instead."]})]}),"\n",(0,i.jsx)(r.h2,{id:"simon",children:"Simon"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-luau",children:"local Simon = Cryptography.Encryption.Simon\n"})}),"\n",(0,i.jsx)(r.p,{children:"NSA designed lightweight block cipher. Optimized for hardware, but also reasonably fast in software."}),"\n",(0,i.jsx)(r.h3,{id:"simonencryptplaintextbuffer-buffer-keybuffer-buffer---buffer",children:(0,i.jsx)(r.code,{children:"Simon.Encrypt(PlaintextBuffer: buffer, KeyBuffer: buffer) -> buffer"})}),"\n",(0,i.jsx)(r.h3,{id:"simondecryptcipherbuffer-buffer-keybuffer-buffer---buffer",children:(0,i.jsx)(r.code,{children:"Simon.Decrypt(CipherBuffer: buffer, KeyBuffer: buffer) -> buffer"})}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Parameter"}),(0,i.jsx)(r.th,{children:"Size"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Key"}),(0,i.jsx)(r.td,{children:"16 bytes"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Block"}),(0,i.jsx)(r.td,{children:"8 bytes (64 bit)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Rounds"}),(0,i.jsx)(r.td,{children:"44"})]})]})]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-luau",children:'local Key = buffer.fromstring("MySecretKey12345") -- exactly 16 bytes\nlocal Encrypted = Simon.Encrypt(buffer.fromstring("Hello World"), Key)\nlocal Decrypted = Simon.Decrypt(Encrypted, Key)\n'})}),"\n",(0,i.jsx)(r.p,{children:"Messages are automatically padded to 8 byte blocks. The padding is included in the ciphertext."}),"\n",(0,i.jsxs)(r.admonition,{title:"No Authentication",type:"warning",children:[(0,i.jsx)(r.p,{children:"Simon is a raw block cipher. There is no authentication, so an attacker can modify ciphertext without detection. It is also in ECB mode, meaning identical plaintext blocks produce identical ciphertext blocks."}),(0,i.jsx)(r.p,{children:"For anything serious, use AEAD or AES GCM."})]}),"\n",(0,i.jsx)(r.h2,{id:"speck",children:"Speck"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-luau",children:"local Speck = Cryptography.Encryption.Speck\n"})}),"\n",(0,i.jsx)(r.p,{children:"Another NSA lightweight cipher, optimized for software performance."}),"\n",(0,i.jsx)(r.h3,{id:"speckencryptplaintextbuffer-buffer-keybuffer-buffer---buffer",children:(0,i.jsx)(r.code,{children:"Speck.Encrypt(PlaintextBuffer: buffer, KeyBuffer: buffer) -> buffer"})}),"\n",(0,i.jsx)(r.h3,{id:"speckdecryptcipherbuffer-buffer-keybuffer-buffer---buffer",children:(0,i.jsx)(r.code,{children:"Speck.Decrypt(CipherBuffer: buffer, KeyBuffer: buffer) -> buffer"})}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Parameter"}),(0,i.jsx)(r.th,{children:"Size"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Key"}),(0,i.jsx)(r.td,{children:"16 bytes"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Block"}),(0,i.jsx)(r.td,{children:"8 bytes (64 bit)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Rounds"}),(0,i.jsx)(r.td,{children:"27"})]})]})]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-luau",children:'local Key = buffer.fromstring("MySecretKey12345") -- exactly 16 bytes\nlocal Encrypted = Speck.Encrypt(buffer.fromstring("Hello World"), Key)\nlocal Decrypted = Speck.Decrypt(Encrypted, Key)\n'})}),"\n",(0,i.jsx)(r.p,{children:"Same caveats as Simon: no authentication, ECB mode, automatic padding."}),"\n",(0,i.jsx)(r.h2,{id:"simon-vs-speck",children:"Simon vs Speck"}),"\n",(0,i.jsx)(r.p,{children:"Both were released by the NSA in 2013. The main differences:"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{}),(0,i.jsx)(r.th,{children:"Simon"}),(0,i.jsx)(r.th,{children:"Speck"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Design"}),(0,i.jsx)(r.td,{children:"Feistel network"}),(0,i.jsx)(r.td,{children:"ARX (add rotate xor)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Optimized for"}),(0,i.jsx)(r.td,{children:"Hardware"}),(0,i.jsx)(r.td,{children:"Software"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Rounds (64 bit block)"}),(0,i.jsx)(r.td,{children:"44"}),(0,i.jsx)(r.td,{children:"27"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Operations"}),(0,i.jsx)(r.td,{children:"AND, XOR, rotate"}),(0,i.jsx)(r.td,{children:"Add, rotate, XOR"})]})]})]}),"\n",(0,i.jsx)(r.p,{children:"In pure Luau, Speck is typically faster due to fewer rounds and simpler operations. Neither has received as much public cryptanalysis as AES."}),"\n",(0,i.jsx)(r.h2,{id:"when-to-use-these",children:"When to Use These"}),"\n",(0,i.jsx)(r.p,{children:"Probably never for security critical applications."}),"\n",(0,i.jsx)(r.p,{children:"These might make sense if you need to obfuscate data where security is not critical, are constrained by message size and cannot afford AEAD's tag overhead, need compatibility with systems already using Simon/Speck, or understand the risks and have other authentication mechanisms."}),"\n",(0,i.jsx)(r.p,{children:"For everything else, use AEAD (ChaCha20 Poly1305) or AES GCM."})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453(e,r,t){t.d(r,{R:()=>c,x:()=>d});var n=t(6540);const i={},s=n.createContext(i);function c(e){const r=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(s.Provider,{value:r},e.children)}}}]);