"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[913],{5014(e,n,s){s.d(n,{A:()=>d,W:()=>l});var r=s(6540),i=s(5622),t=s(5293),a=(s(1388),s(4848));function l(e,n,s){return{id:e,source:n,target:s,type:"smoothstep",animated:!0}}function o({nodes:e,edges:n}){const{colorMode:s}=(0,t.G)(),l="dark"===s,o=(0,i.VH)(),d=(0,r.useRef)(null);(0,r.useEffect)(()=>{if(!d.current)return;const e=new ResizeObserver(()=>{o.fitView({padding:.2})});return e.observe(d.current),()=>e.disconnect()},[o]);return(0,a.jsx)("div",{ref:d,style:{width:"100%",height:"100%"},children:(0,a.jsx)(i.Gc,{nodes:e(e=>({background:e,color:"#fff",border:"none",borderRadius:8,fontSize:14,padding:"10px 20px"}),l),edges:n,fitView:!0,fitViewOptions:{padding:.2},preventScrolling:!1,nodesDraggable:!1,nodesConnectable:!1,elementsSelectable:!1,proOptions:{hideAttribution:!0}})})}function d({nodes:e,edges:n,className:s}){return(0,a.jsx)("div",{className:s,children:(0,a.jsx)(i.Ln,{children:(0,a.jsx)(o,{nodes:e,edges:n})})})}},9049(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>u,default:()=>b,frontMatter:()=>d,metadata:()=>r,toc:()=>f});const r=JSON.parse('{"id":"signatures/mldsa","title":"ML DSA (Post Quantum Signatures)","description":"Module Lattice Digital Signature Algorithm. This is the NIST post quantum signature standard, formerly known as Dilithium. Use this when you need signatures that will remain secure even against quantum computers.","source":"@site/docs/signatures/mldsa.md","sourceDirName":"signatures","slug":"/signatures/mldsa","permalink":"/docs/signatures/mldsa","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/signatures/mldsa.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"X25519","permalink":"/docs/signatures/x25519"},"next":{"title":"ML KEM (Post Quantum Key Exchange)","permalink":"/docs/signatures/mlkem"}}');var i=s(4848),t=s(8453),a=s(5622),l=s(5014);function o(){return(0,i.jsx)(l.A,{className:"mldsa-flow-wrapper",nodes:(e,n)=>[{id:"gen",position:{x:0,y:70},data:{label:"GenerateKeys"},style:e(n?"#22c55e":"#4ade80"),sourcePosition:a.yX.Right},{id:"sk",position:{x:200,y:0},data:{label:"SecretKey"},style:e(n?"#22c55e":"#4ade80"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"pk",position:{x:200,y:140},data:{label:"PublicKey"},style:e(n?"#22c55e":"#4ade80"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"msg",position:{x:200,y:70},data:{label:"Message"},style:e(n?"#6366f1":"#818cf8"),sourcePosition:a.yX.Right},{id:"sign",position:{x:400,y:35},data:{label:"Sign"},style:e(n?"#8b5cf6":"#a78bfa"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"sig",position:{x:580,y:35},data:{label:"Signature"},style:e(n?"#f59e0b":"#fbbf24"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"verify",position:{x:760,y:70},data:{label:"Verify"},style:e(n?"#8b5cf6":"#a78bfa"),targetPosition:a.yX.Left,sourcePosition:a.yX.Right},{id:"valid",position:{x:940,y:70},data:{label:"Valid"},style:e(n?"#16a34a":"#22c55e"),targetPosition:a.yX.Left}],edges:[(0,l.W)("gen-sk","gen","sk"),(0,l.W)("gen-pk","gen","pk"),(0,l.W)("sk-sign","sk","sign"),(0,l.W)("msg-sign","msg","sign"),(0,l.W)("sign-sig","sign","sig"),(0,l.W)("sig-verify","sig","verify"),(0,l.W)("pk-verify","pk","verify"),(0,l.W)("msg-verify","msg","verify"),(0,l.W)("verify-valid","verify","valid")]})}const d={sidebar_position:3},u="ML DSA (Post Quantum Signatures)",c={},f=[{value:"Security Levels",id:"security-levels",level:2},{value:"Key Generation",id:"key-generation",level:2},{value:"<code>ML_DSA_44.GenerateKeys() -&gt; (buffer, buffer)</code>",id:"ml_dsa_44generatekeys---buffer-buffer",level:3},{value:"<code>ML_DSA_65.GenerateKeys() -&gt; (buffer, buffer)</code>",id:"ml_dsa_65generatekeys---buffer-buffer",level:3},{value:"<code>ML_DSA_87.GenerateKeys() -&gt; (buffer, buffer)</code>",id:"ml_dsa_87generatekeys---buffer-buffer",level:3},{value:"Signing",id:"signing",level:2},{value:"<code>ML_DSA_44.Sign(Message: buffer, RandomSeed: buffer, SecretKey: buffer, Context: buffer, Signature: buffer) -&gt; boolean</code>",id:"ml_dsa_44signmessage-buffer-randomseed-buffer-secretkey-buffer-context-buffer-signature-buffer---boolean",level:3},{value:"<code>ML_DSA_65.Sign(Message: buffer, RandomSeed: buffer, SecretKey: buffer, Context: buffer, Signature: buffer) -&gt; boolean</code>",id:"ml_dsa_65signmessage-buffer-randomseed-buffer-secretkey-buffer-context-buffer-signature-buffer---boolean",level:3},{value:"<code>ML_DSA_87.Sign(Message: buffer, RandomSeed: buffer, SecretKey: buffer, Context: buffer, Signature: buffer) -&gt; boolean</code>",id:"ml_dsa_87signmessage-buffer-randomseed-buffer-secretkey-buffer-context-buffer-signature-buffer---boolean",level:3},{value:"Verification",id:"verification",level:2},{value:"<code>ML_DSA_44.Verify(Message: buffer, PublicKey: buffer, Context: buffer, Signature: buffer) -&gt; boolean</code>",id:"ml_dsa_44verifymessage-buffer-publickey-buffer-context-buffer-signature-buffer---boolean",level:3},{value:"<code>ML_DSA_65.Verify(Message: buffer, PublicKey: buffer, Context: buffer, Signature: buffer) -&gt; boolean</code>",id:"ml_dsa_65verifymessage-buffer-publickey-buffer-context-buffer-signature-buffer---boolean",level:3},{value:"<code>ML_DSA_87.Verify(Message: buffer, PublicKey: buffer, Context: buffer, Signature: buffer) -&gt; boolean</code>",id:"ml_dsa_87verifymessage-buffer-publickey-buffer-context-buffer-signature-buffer---boolean",level:3},{value:"Size Constants",id:"size-constants",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"When to Use ML DSA",id:"when-to-use-ml-dsa",level:2},{value:"Examples",id:"examples",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function g(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"ml-dsa-post-quantum-signatures",children:"ML DSA (Post Quantum Signatures)"})}),"\n","\n",(0,i.jsx)(n.p,{children:"Module Lattice Digital Signature Algorithm. This is the NIST post quantum signature standard, formerly known as Dilithium. Use this when you need signatures that will remain secure even against quantum computers."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:"local Mldsa = Cryptography.Verification.Mldsa\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-levels",children:"Security Levels"}),"\n",(0,i.jsx)(n.p,{children:"Three variants with increasing security (and size):"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Variant"}),(0,i.jsx)(n.th,{children:"Security"}),(0,i.jsx)(n.th,{children:"Public Key"}),(0,i.jsx)(n.th,{children:"Secret Key"}),(0,i.jsx)(n.th,{children:"Signature"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ML_DSA_44"}),(0,i.jsx)(n.td,{children:"AES 128 equivalent"}),(0,i.jsx)(n.td,{children:"1,312 bytes"}),(0,i.jsx)(n.td,{children:"2,560 bytes"}),(0,i.jsx)(n.td,{children:"2,420 bytes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ML_DSA_65"}),(0,i.jsx)(n.td,{children:"AES 192 equivalent"}),(0,i.jsx)(n.td,{children:"1,952 bytes"}),(0,i.jsx)(n.td,{children:"4,032 bytes"}),(0,i.jsx)(n.td,{children:"3,309 bytes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ML_DSA_87"}),(0,i.jsx)(n.td,{children:"AES 256 equivalent"}),(0,i.jsx)(n.td,{children:"2,592 bytes"}),(0,i.jsx)(n.td,{children:"4,896 bytes"}),(0,i.jsx)(n.td,{children:"4,627 bytes"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Compare to Ed25519's 32 byte keys and 64 byte signatures. The size increase is the price of quantum resistance."}),"\n",(0,i.jsx)(n.h2,{id:"key-generation",children:"Key Generation"}),"\n",(0,i.jsx)(n.h3,{id:"ml_dsa_44generatekeys---buffer-buffer",children:(0,i.jsx)(n.code,{children:"ML_DSA_44.GenerateKeys() -> (buffer, buffer)"})}),"\n",(0,i.jsx)(n.h3,{id:"ml_dsa_65generatekeys---buffer-buffer",children:(0,i.jsx)(n.code,{children:"ML_DSA_65.GenerateKeys() -> (buffer, buffer)"})}),"\n",(0,i.jsx)(n.h3,{id:"ml_dsa_87generatekeys---buffer-buffer",children:(0,i.jsx)(n.code,{children:"ML_DSA_87.GenerateKeys() -> (buffer, buffer)"})}),"\n",(0,i.jsx)(n.p,{children:"Generates a keypair. Returns (PublicKey, SecretKey)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:"local PublicKey, SecretKey = Mldsa.ML_DSA_65.GenerateKeys()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"signing",children:"Signing"}),"\n",(0,i.jsx)(n.h3,{id:"ml_dsa_44signmessage-buffer-randomseed-buffer-secretkey-buffer-context-buffer-signature-buffer---boolean",children:(0,i.jsx)(n.code,{children:"ML_DSA_44.Sign(Message: buffer, RandomSeed: buffer, SecretKey: buffer, Context: buffer, Signature: buffer) -> boolean"})}),"\n",(0,i.jsx)(n.h3,{id:"ml_dsa_65signmessage-buffer-randomseed-buffer-secretkey-buffer-context-buffer-signature-buffer---boolean",children:(0,i.jsx)(n.code,{children:"ML_DSA_65.Sign(Message: buffer, RandomSeed: buffer, SecretKey: buffer, Context: buffer, Signature: buffer) -> boolean"})}),"\n",(0,i.jsx)(n.h3,{id:"ml_dsa_87signmessage-buffer-randomseed-buffer-secretkey-buffer-context-buffer-signature-buffer---boolean",children:(0,i.jsx)(n.code,{children:"ML_DSA_87.Sign(Message: buffer, RandomSeed: buffer, SecretKey: buffer, Context: buffer, Signature: buffer) -> boolean"})}),"\n",(0,i.jsx)(n.p,{children:"Signs a message. You provide the signature buffer to write into. Returns true on success."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:'local Message = buffer.fromstring("Important document")\nlocal RandomSeed = CSPRNG.RandomBytes(32)\nlocal Context = buffer.fromstring("my application context")\nlocal Signature = buffer.create(Mldsa.ML_DSA_65.SigByteLen)\n\nlocal Success = Mldsa.ML_DSA_65.Sign(Message, RandomSeed, SecretKey, Context, Signature)\nif Success then\n    print("Signed successfully")\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Message"}),": The data to sign"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RandomSeed"}),": 32 bytes of randomness for hedged signing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SecretKey"}),": Your secret key from GenerateKeys"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Context"}),": Application specific context string (can be empty buffer)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Signature"}),": Pre allocated buffer to write signature into (use ",(0,i.jsx)(n.code,{children:"SigByteLen"})," for size)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"verification",children:"Verification"}),"\n",(0,i.jsx)(n.h3,{id:"ml_dsa_44verifymessage-buffer-publickey-buffer-context-buffer-signature-buffer---boolean",children:(0,i.jsx)(n.code,{children:"ML_DSA_44.Verify(Message: buffer, PublicKey: buffer, Context: buffer, Signature: buffer) -> boolean"})}),"\n",(0,i.jsx)(n.h3,{id:"ml_dsa_65verifymessage-buffer-publickey-buffer-context-buffer-signature-buffer---boolean",children:(0,i.jsx)(n.code,{children:"ML_DSA_65.Verify(Message: buffer, PublicKey: buffer, Context: buffer, Signature: buffer) -> boolean"})}),"\n",(0,i.jsx)(n.h3,{id:"ml_dsa_87verifymessage-buffer-publickey-buffer-context-buffer-signature-buffer---boolean",children:(0,i.jsx)(n.code,{children:"ML_DSA_87.Verify(Message: buffer, PublicKey: buffer, Context: buffer, Signature: buffer) -> boolean"})}),"\n",(0,i.jsxs)(n.p,{children:["Returns ",(0,i.jsx)(n.code,{children:"true"})," if the signature is valid."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:'local IsValid = Mldsa.ML_DSA_65.Verify(Message, PublicKey, Context, Signature)\nif IsValid then\n    print("Signature verified")\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:"The context must match what was used during signing."}),"\n",(0,i.jsx)(n.h2,{id:"size-constants",children:"Size Constants"}),"\n",(0,i.jsx)(n.p,{children:"Each variant exposes size constants so you do not need to remember exact byte lengths:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:"-- ML_DSA_44\nMldsa.ML_DSA_44.SigByteLen   -- signature size\nMldsa.ML_DSA_44.PKByteLen    -- public key size\nMldsa.ML_DSA_44.SKByteLen    -- secret key size\n\n-- ML_DSA_65\nMldsa.ML_DSA_65.SigByteLen\nMldsa.ML_DSA_65.PKByteLen\nMldsa.ML_DSA_65.SKByteLen\n\n-- ML_DSA_87\nMldsa.ML_DSA_87.SigByteLen\nMldsa.ML_DSA_87.PKByteLen\nMldsa.ML_DSA_87.SKByteLen\n"})}),"\n",(0,i.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,i.jsx)(n.p,{children:"ML DSA is based on the hardness of the Module Learning With Errors (M LWE) and Module Short Integer Solution (M SIS) problems. These are believed to be hard even for quantum computers."}),"\n",(0,i.jsx)(n.p,{children:"The implementation uses Number Theoretic Transform (NTT) for fast polynomial multiplication, rejection sampling during signature generation, and SHAKE256 for internal hashing and randomness expansion."}),"\n",(0,i.jsx)(n.p,{children:"Signature generation involves some rejection sampling, so signing time can vary slightly. Verification is deterministic and consistent."}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-ml-dsa",children:"When to Use ML DSA"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Use ML DSA when:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You are protecting data that needs to remain secure for decades"}),"\n",(0,i.jsx)(n.li,{children:"Regulatory requirements mandate post quantum cryptography"}),"\n",(0,i.jsx)(n.li,{children:"You are building infrastructure that cannot be easily updated later"}),"\n",(0,i.jsx)(n.li,{children:"Harvest now, decrypt later attacks are a concern for your threat model"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Stick with Ed25519 when:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Key and signature size matter (ML DSA is 40 to 70x larger)"}),"\n",(0,i.jsx)(n.li,{children:"You need maximum performance"}),"\n",(0,i.jsx)(n.li,{children:"Your data does not need multi decade protection"}),"\n",(0,i.jsx)(n.li,{children:"You can migrate to post quantum later when needed"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-luau",children:'-- Signer generates keypair\nlocal PublicKey, SecretKey = Mldsa.ML_DSA_65.GenerateKeys()\n\n-- Signer signs a message\nlocal Message = buffer.fromstring("Important document")\nlocal RandomSeed = CSPRNG.RandomBytes(32)\nlocal Context = buffer.fromstring("my app")\nlocal Signature = buffer.create(Mldsa.ML_DSA_65.SigByteLen)\n\nMldsa.ML_DSA_65.Sign(Message, RandomSeed, SecretKey, Context, Signature)\n\n-- Send: Message, Signature, PublicKey\n\n-- Verifier checks signature\nlocal IsValid = Mldsa.ML_DSA_65.Verify(Message, PublicKey, Context, Signature)\n'})}),"\n",(0,i.jsx)(o,{}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.p,{children:"ML DSA is significantly slower than Ed25519. Key generation is around 10 to 50x slower, signing is around 5 to 20x slower (with rejection sampling variance), and verification is around 5 to 10x slower."}),"\n",(0,i.jsx)(n.p,{children:"The exact ratios depend on the security level and message size. For most applications this is still fast enough, but do not use ML DSA in tight loops or high frequency signing scenarios without benchmarking."})]})}function b(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(g,{...e})}):g(e)}}}]);