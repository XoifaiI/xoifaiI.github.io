"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[67],{109(e,s,i){i.r(s),i.d(s,{assets:()=>h,contentTitle:()=>l,default:()=>g,frontMatter:()=>d,metadata:()=>n,toc:()=>u});const n=JSON.parse('{"id":"hashing/hmac","title":"HMAC","description":"Hash based Message Authentication Code. The standard way to create a MAC from a hash function when you need compatibility with existing systems.","source":"@site/docs/hashing/hmac.md","sourceDirName":"hashing","slug":"/hashing/hmac","permalink":"/docs/hashing/hmac","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/hashing/hmac.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"BLAKE","permalink":"/docs/hashing/blake"},"next":{"title":"KMAC","permalink":"/docs/hashing/kmac"}}');var t=i(4848),a=i(8453),o=i(5622),r=i(5014);function c(){return(0,t.jsx)(r.A,{className:"hmac-flow-wrapper",nodes:(e,s)=>[{id:"m",position:{x:0,y:0},data:{label:"Message"},style:e(s?"#6366f1":"#818cf8"),sourcePosition:o.yX.Right},{id:"k",position:{x:0,y:70},data:{label:"Secret Key"},style:e(s?"#22c55e":"#4ade80"),sourcePosition:o.yX.Right},{id:"h",position:{x:200,y:35},data:{label:"HMAC"},style:e(s?"#8b5cf6":"#a78bfa"),targetPosition:o.yX.Left,sourcePosition:o.yX.Right},{id:"mac",position:{x:380,y:35},data:{label:"MAC Tag"},style:e(s?"#f59e0b":"#fbbf24"),targetPosition:o.yX.Left,sourcePosition:o.yX.Bottom},{id:"m2",position:{x:0,y:160},data:{label:"Message"},style:e(s?"#6366f1":"#818cf8"),sourcePosition:o.yX.Right},{id:"k2",position:{x:0,y:230},data:{label:"Secret Key"},style:e(s?"#22c55e":"#4ade80"),sourcePosition:o.yX.Right},{id:"v",position:{x:200,y:160},data:{label:"Verify"},style:e(s?"#8b5cf6":"#a78bfa"),targetPosition:o.yX.Left,sourcePosition:o.yX.Right},{id:"valid",position:{x:380,y:160},data:{label:"Valid"},style:e(s?"#16a34a":"#22c55e"),targetPosition:o.yX.Left}],edges:[(0,r.W)("m-h","m","h"),(0,r.W)("k-h","k","h"),(0,r.W)("h-mac","h","mac"),(0,r.W)("mac-v","mac","v"),(0,r.W)("m2-v","m2","v"),(0,r.W)("k2-v","k2","v"),(0,r.W)("v-valid","v","valid")]})}const d={sidebar_position:4},l="HMAC",h={},u=[{value:"Function",id:"function",level:2},{value:"<code>HMAC(Message: buffer, Key: buffer, HashFn: function, BlockSize: number, BigEndian: boolean?) -&gt; (string, buffer)</code>",id:"hmacmessage-buffer-key-buffer-hashfn-function-blocksize-number-bigendian-boolean---string-buffer",level:3},{value:"How It Works",id:"how-it-works",level:2},{value:"When to Use It",id:"when-to-use-it",level:2}];function f(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"hmac",children:"HMAC"})}),"\n","\n",(0,t.jsx)(s.p,{children:"Hash based Message Authentication Code. The standard way to create a MAC from a hash function when you need compatibility with existing systems."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-luau",children:"local HMAC = Cryptography.Hashing.HMAC\n"})}),"\n",(0,t.jsx)(s.h2,{id:"function",children:"Function"}),"\n",(0,t.jsx)(s.h3,{id:"hmacmessage-buffer-key-buffer-hashfn-function-blocksize-number-bigendian-boolean---string-buffer",children:(0,t.jsx)(s.code,{children:"HMAC(Message: buffer, Key: buffer, HashFn: function, BlockSize: number, BigEndian: boolean?) -> (string, buffer)"})}),"\n",(0,t.jsx)(s.p,{children:"Generic HMAC that works with any hash function."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-luau",children:'local SHA256 = Cryptography.Hashing.SHA2.SHA256\nlocal Blake3Digest = Cryptography.Hashing.Blake3.Digest\n\n-- HMAC with SHA256\nlocal Key = CSPRNG.RandomBytes(32)\nlocal Message = buffer.fromstring("Hello World")\nlocal HexMac, RawMac = HMAC(Message, Key, SHA256, 64, true)\n\n-- HMAC with BLAKE3 (use BigEndian = false for SHA3/BLAKE family)\nlocal HexMac2, RawMac2 = HMAC(Message, Key, Blake3Digest, 64, false)\n'})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Parameters:"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Message"}),": The data to authenticate"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Key"}),": Your secret key"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"HashFn"}),": The hash function to use (must return string, buffer)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"BlockSize"}),": The block size of the hash function (64 for SHA256, 128 for SHA512)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"BigEndian"}),": Set to ",(0,t.jsx)(s.code,{children:"true"})," for SHA2, ",(0,t.jsx)(s.code,{children:"false"})," for SHA3/BLAKE family"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsxs)(s.p,{children:["HMAC computes ",(0,t.jsx)(s.code,{children:"H((K \u2295 opad) || H((K \u2295 ipad) || M))"})," where K is the key (padded or hashed to block size), opad is 0x5c repeated, ipad is 0x36 repeated, and M is your message."]}),"\n",(0,t.jsx)(s.p,{children:"Keys longer than the hash's block size get hashed first. Keys shorter than the block size are zero padded. For best security, use a key at least as long as the hash output."}),"\n",(0,t.jsx)(c,{}),"\n",(0,t.jsx)(s.h2,{id:"when-to-use-it",children:"When to Use It"}),"\n",(0,t.jsx)(s.p,{children:"HMAC is the right choice when you need API authentication tokens, message integrity with sender verification, JWT signatures, or compatibility with existing HMAC based protocols."}),"\n",(0,t.jsx)(s.p,{children:"If you are building something new and do not need HMAC specifically, BLAKE3 DigestKeyed or BLAKE2b with a key are faster alternatives."})]})}function g(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(f,{...e})}):f(e)}},5014(e,s,i){i.d(s,{A:()=>d,W:()=>r});var n=i(6540),t=i(5622),a=i(5293),o=(i(1388),i(4848));function r(e,s,i){return{id:e,source:s,target:i,type:"smoothstep",animated:!0}}function c({nodes:e,edges:s}){const{colorMode:i}=(0,a.G)(),r="dark"===i,c=(0,t.VH)(),d=(0,n.useRef)(null);(0,n.useEffect)(()=>{if(!d.current)return;const e=new ResizeObserver(()=>{c.fitView({padding:.2})});return e.observe(d.current),()=>e.disconnect()},[c]);return(0,o.jsx)("div",{ref:d,style:{width:"100%",height:"100%"},children:(0,o.jsx)(t.Gc,{nodes:e(e=>({background:e,color:"#fff",border:"none",borderRadius:8,fontSize:14,padding:"10px 20px"}),r),edges:s,fitView:!0,fitViewOptions:{padding:.2},preventScrolling:!1,nodesDraggable:!1,nodesConnectable:!1,elementsSelectable:!1,proOptions:{hideAttribution:!0}})})}function d({nodes:e,edges:s,className:i}){return(0,o.jsx)("div",{className:i,children:(0,o.jsx)(t.Ln,{children:(0,o.jsx)(c,{nodes:e,edges:s})})})}}}]);