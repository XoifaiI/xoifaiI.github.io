"use strict";(globalThis.webpackChunkrbx_cryptography_docs=globalThis.webpackChunkrbx_cryptography_docs||[]).push([[9976],{349(e,n,r){r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>f,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"signatures/mlkem","title":"ML KEM (Post Quantum Key Exchange)","description":"Module Lattice Key Encapsulation Mechanism. This is the NIST post quantum key exchange standard, formerly known as Kyber. Use this to establish shared secrets that will remain secure against quantum computers.","source":"@site/docs/signatures/mlkem.md","sourceDirName":"signatures","slug":"/signatures/mlkem","permalink":"/docs/signatures/mlkem","draft":false,"unlisted":false,"editUrl":"https://github.com/daily3014/rbx-cryptography/tree/main/docs/docs/signatures/mlkem.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"ML DSA (Post Quantum Signatures)","permalink":"/docs/signatures/mldsa"},"next":{"title":"Utilities","permalink":"/docs/category/utilities"}}');var l=r(4848),s=r(8453);const a={sidebar_position:4},c="ML KEM (Post Quantum Key Exchange)",i={},d=[{value:"Security Levels",id:"security-levels",level:2},{value:"Key Generation",id:"key-generation",level:2},{value:"<code>MLKEM_512.GenerateKeys() -&gt; (buffer, buffer)</code>",id:"mlkem_512generatekeys---buffer-buffer",level:3},{value:"<code>MLKEM_768.GenerateKeys() -&gt; (buffer, buffer)</code>",id:"mlkem_768generatekeys---buffer-buffer",level:3},{value:"<code>MLKEM_1024.GenerateKeys() -&gt; (buffer, buffer)</code>",id:"mlkem_1024generatekeys---buffer-buffer",level:3},{value:"<code>MLKEM_512.KeyGen(D: buffer, Z: buffer) -&gt; (buffer, buffer)</code>",id:"mlkem_512keygend-buffer-z-buffer---buffer-buffer",level:3},{value:"<code>MLKEM_768.KeyGen(D: buffer, Z: buffer) -&gt; (buffer, buffer)</code>",id:"mlkem_768keygend-buffer-z-buffer---buffer-buffer",level:3},{value:"<code>MLKEM_1024.KeyGen(D: buffer, Z: buffer) -&gt; (buffer, buffer)</code>",id:"mlkem_1024keygend-buffer-z-buffer---buffer-buffer",level:3},{value:"Encapsulation",id:"encapsulation",level:2},{value:"<code>MLKEM_512.Encapsulate(Message: buffer, PublicKey: buffer) -&gt; (buffer?, buffer?)</code>",id:"mlkem_512encapsulatemessage-buffer-publickey-buffer---buffer-buffer",level:3},{value:"<code>MLKEM_768.Encapsulate(Message: buffer, PublicKey: buffer) -&gt; (buffer?, buffer?)</code>",id:"mlkem_768encapsulatemessage-buffer-publickey-buffer---buffer-buffer",level:3},{value:"<code>MLKEM_1024.Encapsulate(Message: buffer, PublicKey: buffer) -&gt; (buffer?, buffer?)</code>",id:"mlkem_1024encapsulatemessage-buffer-publickey-buffer---buffer-buffer",level:3},{value:"Decapsulation",id:"decapsulation",level:2},{value:"<code>MLKEM_512.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -&gt; buffer</code>",id:"mlkem_512decapsulateciphertext-buffer-secretkey-buffer---buffer",level:3},{value:"<code>MLKEM_768.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -&gt; buffer</code>",id:"mlkem_768decapsulateciphertext-buffer-secretkey-buffer---buffer",level:3},{value:"<code>MLKEM_1024.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -&gt; buffer</code>",id:"mlkem_1024decapsulateciphertext-buffer-secretkey-buffer---buffer",level:3},{value:"KEM vs DH",id:"kem-vs-dh",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Examples",id:"examples",level:2},{value:"Hybrid Key Exchange",id:"hybrid-key-exchange",level:3},{value:"When to Use ML KEM",id:"when-to-use-ml-kem",level:2},{value:"Performance Notes",id:"performance-notes",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"ml-kem-post-quantum-key-exchange",children:"ML KEM (Post Quantum Key Exchange)"})}),"\n",(0,l.jsx)(n.p,{children:"Module Lattice Key Encapsulation Mechanism. This is the NIST post quantum key exchange standard, formerly known as Kyber. Use this to establish shared secrets that will remain secure against quantum computers."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-luau",children:"local MlKem = Cryptography.Verification.MlKem\n"})}),"\n",(0,l.jsx)(n.h2,{id:"security-levels",children:"Security Levels"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Variant"}),(0,l.jsx)(n.th,{children:"Security"}),(0,l.jsx)(n.th,{children:"Public Key"}),(0,l.jsx)(n.th,{children:"Secret Key"}),(0,l.jsx)(n.th,{children:"Ciphertext"}),(0,l.jsx)(n.th,{children:"Shared Secret"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"MLKEM_512"}),(0,l.jsx)(n.td,{children:"AES 128 equivalent"}),(0,l.jsx)(n.td,{children:"800 bytes"}),(0,l.jsx)(n.td,{children:"1,632 bytes"}),(0,l.jsx)(n.td,{children:"768 bytes"}),(0,l.jsx)(n.td,{children:"32 bytes"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"MLKEM_768"}),(0,l.jsx)(n.td,{children:"AES 192 equivalent"}),(0,l.jsx)(n.td,{children:"1,184 bytes"}),(0,l.jsx)(n.td,{children:"2,400 bytes"}),(0,l.jsx)(n.td,{children:"1,088 bytes"}),(0,l.jsx)(n.td,{children:"32 bytes"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:"MLKEM_1024"}),(0,l.jsx)(n.td,{children:"AES 256 equivalent"}),(0,l.jsx)(n.td,{children:"1,568 bytes"}),(0,l.jsx)(n.td,{children:"3,168 bytes"}),(0,l.jsx)(n.td,{children:"1,568 bytes"}),(0,l.jsx)(n.td,{children:"32 bytes"})]})]})]}),"\n",(0,l.jsx)(n.p,{children:"Compare to X25519's 32 byte keys and no ciphertext (just public key exchange)."}),"\n",(0,l.jsx)(n.h2,{id:"key-generation",children:"Key Generation"}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_512generatekeys---buffer-buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_512.GenerateKeys() -> (buffer, buffer)"})}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_768generatekeys---buffer-buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_768.GenerateKeys() -> (buffer, buffer)"})}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_1024generatekeys---buffer-buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_1024.GenerateKeys() -> (buffer, buffer)"})}),"\n",(0,l.jsx)(n.p,{children:"Generates an encapsulation keypair. Returns (PublicKey, SecretKey)."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-luau",children:"local PublicKey, SecretKey = MlKem.MLKEM_768.GenerateKeys()\n"})}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_512keygend-buffer-z-buffer---buffer-buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_512.KeyGen(D: buffer, Z: buffer) -> (buffer, buffer)"})}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_768keygend-buffer-z-buffer---buffer-buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_768.KeyGen(D: buffer, Z: buffer) -> (buffer, buffer)"})}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_1024keygend-buffer-z-buffer---buffer-buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_1024.KeyGen(D: buffer, Z: buffer) -> (buffer, buffer)"})}),"\n",(0,l.jsx)(n.p,{children:"Deterministic key generation from seed values."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-luau",children:"local D = CSPRNG.RandomBytes(32)\nlocal Z = CSPRNG.RandomBytes(32)\nlocal PublicKey, SecretKey = MlKem.MLKEM_768.KeyGen(D, Z)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"encapsulation",children:"Encapsulation"}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_512encapsulatemessage-buffer-publickey-buffer---buffer-buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_512.Encapsulate(Message: buffer, PublicKey: buffer) -> (buffer?, buffer?)"})}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_768encapsulatemessage-buffer-publickey-buffer---buffer-buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_768.Encapsulate(Message: buffer, PublicKey: buffer) -> (buffer?, buffer?)"})}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_1024encapsulatemessage-buffer-publickey-buffer---buffer-buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_1024.Encapsulate(Message: buffer, PublicKey: buffer) -> (buffer?, buffer?)"})}),"\n",(0,l.jsx)(n.p,{children:"Creates a ciphertext and shared secret using the recipient's public key."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-luau",children:"local Message = CSPRNG.RandomBytes(32)\nlocal Ciphertext, SharedSecret = MlKem.MLKEM_768.Encapsulate(Message, RecipientPublicKey)\nif Ciphertext and SharedSecret then\n    -- Send Ciphertext to recipient\n    -- Use SharedSecret for encryption\n    print(buffer.len(SharedSecret)) -- 32\nend\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Returns ",(0,l.jsx)(n.code,{children:"nil, nil"})," if the public key is invalid."]}),"\n",(0,l.jsx)(n.h2,{id:"decapsulation",children:"Decapsulation"}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_512decapsulateciphertext-buffer-secretkey-buffer---buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_512.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -> buffer"})}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_768decapsulateciphertext-buffer-secretkey-buffer---buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_768.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -> buffer"})}),"\n",(0,l.jsx)(n.h3,{id:"mlkem_1024decapsulateciphertext-buffer-secretkey-buffer---buffer",children:(0,l.jsx)(n.code,{children:"MLKEM_1024.Decapsulate(Ciphertext: buffer, SecretKey: buffer) -> buffer"})}),"\n",(0,l.jsx)(n.p,{children:"Recovers the shared secret using the secret key."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-luau",children:"local SharedSecret = MlKem.MLKEM_768.Decapsulate(Ciphertext, SecretKey)\nprint(buffer.len(SharedSecret)) -- 32\n\n-- SharedSecret matches what Encapsulate produced\n"})}),"\n",(0,l.jsx)(n.h2,{id:"kem-vs-dh",children:"KEM vs DH"}),"\n",(0,l.jsx)(n.p,{children:"Key Encapsulation Mechanisms work differently than Diffie Hellman:"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Diffie Hellman (X25519)"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Alice and Bob exchange public keys"}),"\n",(0,l.jsx)(n.li,{children:"Both compute the same shared secret independently"}),"\n",(0,l.jsx)(n.li,{children:"Symmetric: either party can initiate"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"KEM (ML KEM)"})}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Bob publishes his public key"}),"\n",(0,l.jsx)(n.li,{children:"Alice generates a random message and encapsulates it for Bob"}),"\n",(0,l.jsx)(n.li,{children:"Alice sends the ciphertext to Bob"}),"\n",(0,l.jsx)(n.li,{children:"Bob decapsulates to recover the shared secret"}),"\n",(0,l.jsx)(n.li,{children:"Asymmetric: Alice initiates, Bob receives"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"The KEM model maps naturally to how most protocols work anyway (client initiates connection to server)."}),"\n",(0,l.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,l.jsx)(n.p,{children:"ML KEM is based on the hardness of the Module Learning With Errors (M LWE) problem. The encapsulation process generates a random message, encrypts it using the public key via a lattice based encryption scheme, and derives the final shared secret."}),"\n",(0,l.jsx)(n.p,{children:"The decapsulation process decrypts the ciphertext using the secret key, re encrypts the decrypted message and checks it matches, and if valid derives the shared secret the same way. If invalid, it derives a pseudorandom value (prevents leaking information about failures)."}),"\n",(0,l.jsx)(n.p,{children:"This re encryption check is an implicit rejection mechanism that provides IND CCA2 security."}),"\n",(0,l.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-luau",children:"-- Receiver generates keypair\nlocal PublicKey, SecretKey = MlKem.MLKEM_768.GenerateKeys()\n\n-- Sender encapsulates a shared secret\nlocal Message = CSPRNG.RandomBytes(32)\nlocal Ciphertext, SharedSecret = MlKem.MLKEM_768.Encapsulate(Message, PublicKey)\n\n-- Sender encrypts data with shared secret\nlocal Nonce = CSPRNG.RandomBytes(12)\nlocal EncryptedData, Tag = AEAD.Encrypt(Data, SharedSecret, Nonce)\n\n-- Send: Ciphertext, Nonce, EncryptedData, Tag\n\n-- Receiver decapsulates to get same shared secret\nlocal SharedSecret = MlKem.MLKEM_768.Decapsulate(Ciphertext, SecretKey)\n\n-- Receiver decrypts data\nlocal Data = AEAD.Decrypt(EncryptedData, SharedSecret, Nonce, Tag)\n"})}),"\n",(0,l.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph Receiver\n        Gen[GenerateKeys] --\x3e PK[PublicKey]\n        Gen --\x3e SK[SecretKey]\n    end\n    \n    PK --\x3e Enc\n    \n    subgraph Sender\n        Enc[Encapsulate] --\x3e SS1[SharedSecret]\n        Enc --\x3e CT[Ciphertext]\n        SS1 --\x3e E[Encrypt]\n    end\n    \n    CT --\x3e Dec\n    SK --\x3e Dec\n    \n    subgraph Receiver2[" "]\n        Dec[Decapsulate] --\x3e SS2[SharedSecret]\n        SS2 --\x3e D[Decrypt]\n    end\n    \n    style Gen fill:#3c5a3c\n    style PK fill:#3c5a3c\n    style SK fill:#3c5a3c\n    style Enc fill:#3c3c5a\n    style SS1 fill:#3c3c5a\n    style CT fill:#5a4632\n    style E fill:#503c50\n    style Dec fill:#3c5a3c\n    style SS2 fill:#3c5a3c\n    style D fill:#2a5a2a'}),"\n",(0,l.jsx)(n.h3,{id:"hybrid-key-exchange",children:"Hybrid Key Exchange"}),"\n",(0,l.jsx)(n.p,{children:"Combine ML KEM with X25519 for defense in depth:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-luau",children:'-- Both parties have X25519 and ML KEM keys\n\n-- Classical X25519 exchange\nlocal X25519Shared1, _ = X25519.Exchange(MyMaskedKey, TheirX25519Public)\n\n-- Post quantum ML KEM exchange (initiator side)\nlocal KemMessage = CSPRNG.RandomBytes(32)\nlocal KemCiphertext, KemSecret = MlKem.MLKEM_768.Encapsulate(KemMessage, TheirMlKemPublic)\n\n-- Combine both secrets\nlocal CombinedInput = buffer.create(64)\nbuffer.copy(CombinedInput, 0, X25519Shared1)\nbuffer.copy(CombinedInput, 32, KemSecret)\n\nlocal Context = buffer.fromstring("hybrid key exchange")\nlocal FinalDeriver = Blake3.DeriveKey(Context)\nlocal _, FinalKey = FinalDeriver(CombinedInput, 32)\n'})}),"\n",(0,l.jsx)(n.p,{children:"The responder side:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-luau",children:'local X25519Shared1, _ = X25519.Exchange(MyMaskedKey, TheirX25519Public)\nlocal KemSecret = MlKem.MLKEM_768.Decapsulate(KemCiphertext, MyMlKemSecret)\n\nlocal CombinedInput = buffer.create(64)\nbuffer.copy(CombinedInput, 0, X25519Shared1)\nbuffer.copy(CombinedInput, 32, KemSecret)\n\nlocal Context = buffer.fromstring("hybrid key exchange")\nlocal FinalDeriver = Blake3.DeriveKey(Context)\nlocal _, FinalKey = FinalDeriver(CombinedInput, 32)\n'})}),"\n",(0,l.jsx)(n.p,{children:"This protects against classical attacks (via ML KEM) and potential weaknesses in lattice cryptography (via X25519)."}),"\n",(0,l.jsx)(n.mermaid,{value:'flowchart LR\n    subgraph Initiator\n        X1[X25519.Exchange] --\x3e S1[X25519Shared]\n        KM[RandomBytes] --\x3e Enc[ML KEM Encapsulate]\n        Enc --\x3e KS1[KemSecret]\n        Enc --\x3e CT[Ciphertext]\n    end\n    \n    CT --\x3e|Send| Dec\n    \n    subgraph Responder\n        X2[X25519.Exchange] --\x3e S2[X25519Shared]\n        Dec[ML KEM Decapsulate] --\x3e KS2[KemSecret]\n    end\n    \n    subgraph Combine["Key Derivation"]\n        S1 --\x3e C1[Combine 64 bytes]\n        KS1 --\x3e C1\n        C1 --\x3e B1[Blake3.DeriveKey]\n        B1 --\x3e FK1[FinalKey]\n        \n        S2 --\x3e C2[Combine 64 bytes]\n        KS2 --\x3e C2\n        C2 --\x3e B2[Blake3.DeriveKey]\n        B2 --\x3e FK2[FinalKey]\n    end\n    \n    FK1 -.- Same[Same Key]\n    FK2 -.- Same\n    \n    style X1 fill:#3c3c5a\n    style S1 fill:#3c3c5a\n    style KM fill:#3c5a3c\n    style Enc fill:#3c5a3c\n    style KS1 fill:#3c5a3c\n    style CT fill:#5a4632\n    style X2 fill:#3c3c5a\n    style S2 fill:#3c3c5a\n    style Dec fill:#3c5a3c\n    style KS2 fill:#3c5a3c\n    style C1 fill:#503c50\n    style C2 fill:#503c50\n    style B1 fill:#503c50\n    style B2 fill:#503c50\n    style FK1 fill:#5a5a32\n    style FK2 fill:#5a5a32\n    style Same fill:#2a5a2a'}),"\n",(0,l.jsx)(n.h2,{id:"when-to-use-ml-kem",children:"When to Use ML KEM"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Use ML KEM when:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"You need key exchange that survives quantum computers"}),"\n",(0,l.jsx)(n.li,{children:"Harvest now, decrypt later is a concern"}),"\n",(0,l.jsx)(n.li,{children:"Regulatory requirements mandate post quantum crypto"}),"\n",(0,l.jsx)(n.li,{children:"You are building long lived infrastructure"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Stick with X25519 when:"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Bandwidth is constrained (ML KEM ciphertexts are 768 to 1568 bytes)"}),"\n",(0,l.jsx)(n.li,{children:"Performance is critical"}),"\n",(0,l.jsx)(n.li,{children:"You can migrate to post quantum later"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"performance-notes",children:"Performance Notes"}),"\n",(0,l.jsx)(n.p,{children:"ML KEM is faster than X25519."}),"\n",(0,l.jsx)(n.p,{children:"The bigger concern is typically bandwidth rather than computation. Make sure your protocol can handle the larger key and ciphertext sizes."})]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(u,{...e})}):u(e)}},8453(e,n,r){r.d(n,{R:()=>a,x:()=>c});var t=r(6540);const l={},s=t.createContext(l);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);